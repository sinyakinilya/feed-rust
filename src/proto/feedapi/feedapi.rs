// This file is generated by rust-protobuf 2.15.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `feedapi.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_15_1;

#[derive(PartialEq,Clone,Default)]
pub struct State {
    // message fields
    pub ID: ::std::string::String,
    pub Code: ::std::string::String,
    pub Params: ::std::vec::Vec<u8>,
    pub CreatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a State {
    fn default() -> &'a State {
        <State as ::protobuf::Message>::default_instance()
    }
}

impl State {
    pub fn new() -> State {
        ::std::default::Default::default()
    }

    // string ID = 1;


    pub fn get_ID(&self) -> &str {
        &self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        &mut self.ID
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ID, ::std::string::String::new())
    }

    // string Code = 2;


    pub fn get_Code(&self) -> &str {
        &self.Code
    }
    pub fn clear_Code(&mut self) {
        self.Code.clear();
    }

    // Param is passed by value, moved
    pub fn set_Code(&mut self, v: ::std::string::String) {
        self.Code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Code(&mut self) -> &mut ::std::string::String {
        &mut self.Code
    }

    // Take field
    pub fn take_Code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Code, ::std::string::String::new())
    }

    // bytes Params = 3;


    pub fn get_Params(&self) -> &[u8] {
        &self.Params
    }
    pub fn clear_Params(&mut self) {
        self.Params.clear();
    }

    // Param is passed by value, moved
    pub fn set_Params(&mut self, v: ::std::vec::Vec<u8>) {
        self.Params = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Params(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Params
    }

    // Take field
    pub fn take_Params(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Params, ::std::vec::Vec::new())
    }

    // .google.protobuf.Timestamp CreatedAt = 4;


    pub fn get_CreatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.CreatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_CreatedAt(&mut self) {
        self.CreatedAt.clear();
    }

    pub fn has_CreatedAt(&self) -> bool {
        self.CreatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CreatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.CreatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.CreatedAt.is_none() {
            self.CreatedAt.set_default();
        }
        self.CreatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CreatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.CreatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for State {
    fn is_initialized(&self) -> bool {
        for v in &self.CreatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Code)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Params)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CreatedAt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ID);
        }
        if !self.Code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Code);
        }
        if !self.Params.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.Params);
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ID.is_empty() {
            os.write_string(1, &self.ID)?;
        }
        if !self.Code.is_empty() {
            os.write_string(2, &self.Code)?;
        }
        if !self.Params.is_empty() {
            os.write_bytes(3, &self.Params)?;
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> State {
        State::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ID",
                    |m: &State| { &m.ID },
                    |m: &mut State| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Code",
                    |m: &State| { &m.Code },
                    |m: &mut State| { &mut m.Code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Params",
                    |m: &State| { &m.Params },
                    |m: &mut State| { &mut m.Params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "CreatedAt",
                    |m: &State| { &m.CreatedAt },
                    |m: &mut State| { &mut m.CreatedAt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<State>(
                    "State",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static State {
        static mut instance: ::protobuf::lazy::Lazy<State> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(State::new)
        }
    }
}

impl ::protobuf::Clear for State {
    fn clear(&mut self) {
        self.ID.clear();
        self.Code.clear();
        self.Params.clear();
        self.CreatedAt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for State {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateStateRequest {
    // message fields
    pub FeedRowID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub State: ::protobuf::SingularPtrField<State>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateStateRequest {
    fn default() -> &'a UpdateStateRequest {
        <UpdateStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateStateRequest {
    pub fn new() -> UpdateStateRequest {
        ::std::default::Default::default()
    }

    // string FeedRowID = 1;


    pub fn get_FeedRowID(&self) -> &str {
        &self.FeedRowID
    }
    pub fn clear_FeedRowID(&mut self) {
        self.FeedRowID.clear();
    }

    // Param is passed by value, moved
    pub fn set_FeedRowID(&mut self, v: ::std::string::String) {
        self.FeedRowID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeedRowID(&mut self) -> &mut ::std::string::String {
        &mut self.FeedRowID
    }

    // Take field
    pub fn take_FeedRowID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.FeedRowID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // .feedapi.State State = 3;


    pub fn get_State(&self) -> &State {
        self.State.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_State(&mut self) {
        self.State.clear();
    }

    pub fn has_State(&self) -> bool {
        self.State.is_some()
    }

    // Param is passed by value, moved
    pub fn set_State(&mut self, v: State) {
        self.State = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_State(&mut self) -> &mut State {
        if self.State.is_none() {
            self.State.set_default();
        }
        self.State.as_mut().unwrap()
    }

    // Take field
    pub fn take_State(&mut self) -> State {
        self.State.take().unwrap_or_else(|| State::new())
    }
}

impl ::protobuf::Message for UpdateStateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.State {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.FeedRowID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.State)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.FeedRowID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.FeedRowID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if let Some(ref v) = self.State.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.FeedRowID.is_empty() {
            os.write_string(1, &self.FeedRowID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if let Some(ref v) = self.State.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateStateRequest {
        UpdateStateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "FeedRowID",
                    |m: &UpdateStateRequest| { &m.FeedRowID },
                    |m: &mut UpdateStateRequest| { &mut m.FeedRowID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &UpdateStateRequest| { &m.AccountID },
                    |m: &mut UpdateStateRequest| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "State",
                    |m: &UpdateStateRequest| { &m.State },
                    |m: &mut UpdateStateRequest| { &mut m.State },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateStateRequest>(
                    "UpdateStateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateStateRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateStateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateStateRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateStateRequest {
    fn clear(&mut self) {
        self.FeedRowID.clear();
        self.AccountID.clear();
        self.State.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateStateResponse {
    // message fields
    pub Error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateStateResponse {
    fn default() -> &'a UpdateStateResponse {
        <UpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateStateResponse {
    pub fn new() -> UpdateStateResponse {
        ::std::default::Default::default()
    }

    // .feedapi.Error Error = 1;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for UpdateStateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateStateResponse {
        UpdateStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &UpdateStateResponse| { &m.Error },
                    |m: &mut UpdateStateResponse| { &mut m.Error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateStateResponse>(
                    "UpdateStateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateStateResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateStateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateStateResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateStateResponse {
    fn clear(&mut self) {
        self.Error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Balance {
    // message fields
    pub Type: ::std::string::String,
    pub Amount: i64,
    pub AssetType: ::std::string::String,
    pub AssetTitle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Balance {
    fn default() -> &'a Balance {
        <Balance as ::protobuf::Message>::default_instance()
    }
}

impl Balance {
    pub fn new() -> Balance {
        ::std::default::Default::default()
    }

    // string Type = 1;


    pub fn get_Type(&self) -> &str {
        &self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // int64 Amount = 2;


    pub fn get_Amount(&self) -> i64 {
        self.Amount
    }
    pub fn clear_Amount(&mut self) {
        self.Amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_Amount(&mut self, v: i64) {
        self.Amount = v;
    }

    // string AssetType = 3;


    pub fn get_AssetType(&self) -> &str {
        &self.AssetType
    }
    pub fn clear_AssetType(&mut self) {
        self.AssetType.clear();
    }

    // Param is passed by value, moved
    pub fn set_AssetType(&mut self, v: ::std::string::String) {
        self.AssetType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AssetType(&mut self) -> &mut ::std::string::String {
        &mut self.AssetType
    }

    // Take field
    pub fn take_AssetType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AssetType, ::std::string::String::new())
    }

    // string AssetTitle = 4;


    pub fn get_AssetTitle(&self) -> &str {
        &self.AssetTitle
    }
    pub fn clear_AssetTitle(&mut self) {
        self.AssetTitle.clear();
    }

    // Param is passed by value, moved
    pub fn set_AssetTitle(&mut self, v: ::std::string::String) {
        self.AssetTitle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AssetTitle(&mut self) -> &mut ::std::string::String {
        &mut self.AssetTitle
    }

    // Take field
    pub fn take_AssetTitle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AssetTitle, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Balance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AssetType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AssetTitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Type);
        }
        if self.Amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.AssetType.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.AssetType);
        }
        if !self.AssetTitle.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.AssetTitle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Type.is_empty() {
            os.write_string(1, &self.Type)?;
        }
        if self.Amount != 0 {
            os.write_int64(2, self.Amount)?;
        }
        if !self.AssetType.is_empty() {
            os.write_string(3, &self.AssetType)?;
        }
        if !self.AssetTitle.is_empty() {
            os.write_string(4, &self.AssetTitle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Balance {
        Balance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Type",
                    |m: &Balance| { &m.Type },
                    |m: &mut Balance| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Amount",
                    |m: &Balance| { &m.Amount },
                    |m: &mut Balance| { &mut m.Amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AssetType",
                    |m: &Balance| { &m.AssetType },
                    |m: &mut Balance| { &mut m.AssetType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AssetTitle",
                    |m: &Balance| { &m.AssetTitle },
                    |m: &mut Balance| { &mut m.AssetTitle },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Balance>(
                    "Balance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Balance {
        static mut instance: ::protobuf::lazy::Lazy<Balance> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Balance::new)
        }
    }
}

impl ::protobuf::Clear for Balance {
    fn clear(&mut self) {
        self.Type.clear();
        self.Amount = 0;
        self.AssetType.clear();
        self.AssetTitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Balance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Balance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationObject {
    // message fields
    pub ID: ::std::string::String,
    pub Title: ::std::string::String,
    pub Url: ::std::string::String,
    pub Meta: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationObject {
    fn default() -> &'a OperationObject {
        <OperationObject as ::protobuf::Message>::default_instance()
    }
}

impl OperationObject {
    pub fn new() -> OperationObject {
        ::std::default::Default::default()
    }

    // string ID = 1;


    pub fn get_ID(&self) -> &str {
        &self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        &mut self.ID
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ID, ::std::string::String::new())
    }

    // string Title = 2;


    pub fn get_Title(&self) -> &str {
        &self.Title
    }
    pub fn clear_Title(&mut self) {
        self.Title.clear();
    }

    // Param is passed by value, moved
    pub fn set_Title(&mut self, v: ::std::string::String) {
        self.Title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Title(&mut self) -> &mut ::std::string::String {
        &mut self.Title
    }

    // Take field
    pub fn take_Title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Title, ::std::string::String::new())
    }

    // string Url = 3;


    pub fn get_Url(&self) -> &str {
        &self.Url
    }
    pub fn clear_Url(&mut self) {
        self.Url.clear();
    }

    // Param is passed by value, moved
    pub fn set_Url(&mut self, v: ::std::string::String) {
        self.Url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Url(&mut self) -> &mut ::std::string::String {
        &mut self.Url
    }

    // Take field
    pub fn take_Url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Url, ::std::string::String::new())
    }

    // bytes Meta = 4;


    pub fn get_Meta(&self) -> &[u8] {
        &self.Meta
    }
    pub fn clear_Meta(&mut self) {
        self.Meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_Meta(&mut self, v: ::std::vec::Vec<u8>) {
        self.Meta = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Meta(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Meta
    }

    // Take field
    pub fn take_Meta(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Meta, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OperationObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Meta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ID);
        }
        if !self.Title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Title);
        }
        if !self.Url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Url);
        }
        if !self.Meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.Meta);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ID.is_empty() {
            os.write_string(1, &self.ID)?;
        }
        if !self.Title.is_empty() {
            os.write_string(2, &self.Title)?;
        }
        if !self.Url.is_empty() {
            os.write_string(3, &self.Url)?;
        }
        if !self.Meta.is_empty() {
            os.write_bytes(4, &self.Meta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationObject {
        OperationObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ID",
                    |m: &OperationObject| { &m.ID },
                    |m: &mut OperationObject| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Title",
                    |m: &OperationObject| { &m.Title },
                    |m: &mut OperationObject| { &mut m.Title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Url",
                    |m: &OperationObject| { &m.Url },
                    |m: &mut OperationObject| { &mut m.Url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Meta",
                    |m: &OperationObject| { &m.Meta },
                    |m: &mut OperationObject| { &mut m.Meta },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationObject>(
                    "OperationObject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationObject {
        static mut instance: ::protobuf::lazy::Lazy<OperationObject> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(OperationObject::new)
        }
    }
}

impl ::protobuf::Clear for OperationObject {
    fn clear(&mut self) {
        self.ID.clear();
        self.Title.clear();
        self.Url.clear();
        self.Meta.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRowRequest {
    // message fields
    pub Rows: ::protobuf::RepeatedField<CreateFeedRowRequest_Row>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRowRequest {
    fn default() -> &'a CreateFeedRowRequest {
        <CreateFeedRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRowRequest {
    pub fn new() -> CreateFeedRowRequest {
        ::std::default::Default::default()
    }

    // repeated .feedapi.CreateFeedRowRequest.Row Rows = 1;


    pub fn get_Rows(&self) -> &[CreateFeedRowRequest_Row] {
        &self.Rows
    }
    pub fn clear_Rows(&mut self) {
        self.Rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rows(&mut self, v: ::protobuf::RepeatedField<CreateFeedRowRequest_Row>) {
        self.Rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rows(&mut self) -> &mut ::protobuf::RepeatedField<CreateFeedRowRequest_Row> {
        &mut self.Rows
    }

    // Take field
    pub fn take_Rows(&mut self) -> ::protobuf::RepeatedField<CreateFeedRowRequest_Row> {
        ::std::mem::replace(&mut self.Rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateFeedRowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Rows {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRowRequest {
        CreateFeedRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateFeedRowRequest_Row>>(
                    "Rows",
                    |m: &CreateFeedRowRequest| { &m.Rows },
                    |m: &mut CreateFeedRowRequest| { &mut m.Rows },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRowRequest>(
                    "CreateFeedRowRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFeedRowRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateFeedRowRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateFeedRowRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateFeedRowRequest {
    fn clear(&mut self) {
        self.Rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRowRequest_Row {
    // message fields
    pub RowID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub PartnerAccountID: ::std::string::String,
    pub GroupID: ::std::string::String,
    pub CreatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub OperationType: ::std::string::String,
    pub OperationObjects: ::protobuf::RepeatedField<OperationObject>,
    pub Balance: ::protobuf::SingularPtrField<Balance>,
    pub ContractorID: ::std::string::String,
    pub State: ::protobuf::SingularPtrField<State>,
    pub Details: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRowRequest_Row {
    fn default() -> &'a CreateFeedRowRequest_Row {
        <CreateFeedRowRequest_Row as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRowRequest_Row {
    pub fn new() -> CreateFeedRowRequest_Row {
        ::std::default::Default::default()
    }

    // string RowID = 1;


    pub fn get_RowID(&self) -> &str {
        &self.RowID
    }
    pub fn clear_RowID(&mut self) {
        self.RowID.clear();
    }

    // Param is passed by value, moved
    pub fn set_RowID(&mut self, v: ::std::string::String) {
        self.RowID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RowID(&mut self) -> &mut ::std::string::String {
        &mut self.RowID
    }

    // Take field
    pub fn take_RowID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RowID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // string PartnerAccountID = 3;


    pub fn get_PartnerAccountID(&self) -> &str {
        &self.PartnerAccountID
    }
    pub fn clear_PartnerAccountID(&mut self) {
        self.PartnerAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_PartnerAccountID(&mut self, v: ::std::string::String) {
        self.PartnerAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PartnerAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.PartnerAccountID
    }

    // Take field
    pub fn take_PartnerAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PartnerAccountID, ::std::string::String::new())
    }

    // string GroupID = 4;


    pub fn get_GroupID(&self) -> &str {
        &self.GroupID
    }
    pub fn clear_GroupID(&mut self) {
        self.GroupID.clear();
    }

    // Param is passed by value, moved
    pub fn set_GroupID(&mut self, v: ::std::string::String) {
        self.GroupID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GroupID(&mut self) -> &mut ::std::string::String {
        &mut self.GroupID
    }

    // Take field
    pub fn take_GroupID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.GroupID, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp CreatedAt = 5;


    pub fn get_CreatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.CreatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_CreatedAt(&mut self) {
        self.CreatedAt.clear();
    }

    pub fn has_CreatedAt(&self) -> bool {
        self.CreatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CreatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.CreatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.CreatedAt.is_none() {
            self.CreatedAt.set_default();
        }
        self.CreatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CreatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.CreatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string OperationType = 6;


    pub fn get_OperationType(&self) -> &str {
        &self.OperationType
    }
    pub fn clear_OperationType(&mut self) {
        self.OperationType.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationType(&mut self, v: ::std::string::String) {
        self.OperationType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OperationType(&mut self) -> &mut ::std::string::String {
        &mut self.OperationType
    }

    // Take field
    pub fn take_OperationType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.OperationType, ::std::string::String::new())
    }

    // repeated .feedapi.OperationObject OperationObjects = 7;


    pub fn get_OperationObjects(&self) -> &[OperationObject] {
        &self.OperationObjects
    }
    pub fn clear_OperationObjects(&mut self) {
        self.OperationObjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationObjects(&mut self, v: ::protobuf::RepeatedField<OperationObject>) {
        self.OperationObjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_OperationObjects(&mut self) -> &mut ::protobuf::RepeatedField<OperationObject> {
        &mut self.OperationObjects
    }

    // Take field
    pub fn take_OperationObjects(&mut self) -> ::protobuf::RepeatedField<OperationObject> {
        ::std::mem::replace(&mut self.OperationObjects, ::protobuf::RepeatedField::new())
    }

    // .feedapi.Balance Balance = 8;


    pub fn get_Balance(&self) -> &Balance {
        self.Balance.as_ref().unwrap_or_else(|| Balance::default_instance())
    }
    pub fn clear_Balance(&mut self) {
        self.Balance.clear();
    }

    pub fn has_Balance(&self) -> bool {
        self.Balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Balance(&mut self, v: Balance) {
        self.Balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Balance(&mut self) -> &mut Balance {
        if self.Balance.is_none() {
            self.Balance.set_default();
        }
        self.Balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_Balance(&mut self) -> Balance {
        self.Balance.take().unwrap_or_else(|| Balance::new())
    }

    // string ContractorID = 9;


    pub fn get_ContractorID(&self) -> &str {
        &self.ContractorID
    }
    pub fn clear_ContractorID(&mut self) {
        self.ContractorID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ContractorID(&mut self, v: ::std::string::String) {
        self.ContractorID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ContractorID(&mut self) -> &mut ::std::string::String {
        &mut self.ContractorID
    }

    // Take field
    pub fn take_ContractorID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ContractorID, ::std::string::String::new())
    }

    // .feedapi.State State = 10;


    pub fn get_State(&self) -> &State {
        self.State.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_State(&mut self) {
        self.State.clear();
    }

    pub fn has_State(&self) -> bool {
        self.State.is_some()
    }

    // Param is passed by value, moved
    pub fn set_State(&mut self, v: State) {
        self.State = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_State(&mut self) -> &mut State {
        if self.State.is_none() {
            self.State.set_default();
        }
        self.State.as_mut().unwrap()
    }

    // Take field
    pub fn take_State(&mut self) -> State {
        self.State.take().unwrap_or_else(|| State::new())
    }

    // bytes Details = 11;


    pub fn get_Details(&self) -> &[u8] {
        &self.Details
    }
    pub fn clear_Details(&mut self) {
        self.Details.clear();
    }

    // Param is passed by value, moved
    pub fn set_Details(&mut self, v: ::std::vec::Vec<u8>) {
        self.Details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Details(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Details
    }

    // Take field
    pub fn take_Details(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Details, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreateFeedRowRequest_Row {
    fn is_initialized(&self) -> bool {
        for v in &self.CreatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.OperationObjects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.State {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.RowID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PartnerAccountID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.GroupID)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CreatedAt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.OperationType)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.OperationObjects)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Balance)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ContractorID)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.State)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.RowID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.RowID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if !self.PartnerAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.PartnerAccountID);
        }
        if !self.GroupID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.GroupID);
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.OperationType.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.OperationType);
        }
        for value in &self.OperationObjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ContractorID.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.ContractorID);
        }
        if let Some(ref v) = self.State.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Details.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.Details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.RowID.is_empty() {
            os.write_string(1, &self.RowID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if !self.PartnerAccountID.is_empty() {
            os.write_string(3, &self.PartnerAccountID)?;
        }
        if !self.GroupID.is_empty() {
            os.write_string(4, &self.GroupID)?;
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.OperationType.is_empty() {
            os.write_string(6, &self.OperationType)?;
        }
        for v in &self.OperationObjects {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ContractorID.is_empty() {
            os.write_string(9, &self.ContractorID)?;
        }
        if let Some(ref v) = self.State.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Details.is_empty() {
            os.write_bytes(11, &self.Details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRowRequest_Row {
        CreateFeedRowRequest_Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RowID",
                    |m: &CreateFeedRowRequest_Row| { &m.RowID },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.RowID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &CreateFeedRowRequest_Row| { &m.AccountID },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PartnerAccountID",
                    |m: &CreateFeedRowRequest_Row| { &m.PartnerAccountID },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.PartnerAccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "GroupID",
                    |m: &CreateFeedRowRequest_Row| { &m.GroupID },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.GroupID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "CreatedAt",
                    |m: &CreateFeedRowRequest_Row| { &m.CreatedAt },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.CreatedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "OperationType",
                    |m: &CreateFeedRowRequest_Row| { &m.OperationType },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.OperationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationObject>>(
                    "OperationObjects",
                    |m: &CreateFeedRowRequest_Row| { &m.OperationObjects },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.OperationObjects },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Balance>>(
                    "Balance",
                    |m: &CreateFeedRowRequest_Row| { &m.Balance },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.Balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ContractorID",
                    |m: &CreateFeedRowRequest_Row| { &m.ContractorID },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.ContractorID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "State",
                    |m: &CreateFeedRowRequest_Row| { &m.State },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.State },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Details",
                    |m: &CreateFeedRowRequest_Row| { &m.Details },
                    |m: &mut CreateFeedRowRequest_Row| { &mut m.Details },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRowRequest_Row>(
                    "CreateFeedRowRequest.Row",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFeedRowRequest_Row {
        static mut instance: ::protobuf::lazy::Lazy<CreateFeedRowRequest_Row> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateFeedRowRequest_Row::new)
        }
    }
}

impl ::protobuf::Clear for CreateFeedRowRequest_Row {
    fn clear(&mut self) {
        self.RowID.clear();
        self.AccountID.clear();
        self.PartnerAccountID.clear();
        self.GroupID.clear();
        self.CreatedAt.clear();
        self.OperationType.clear();
        self.OperationObjects.clear();
        self.Balance.clear();
        self.ContractorID.clear();
        self.State.clear();
        self.Details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRowRequest_Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRowRequest_Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRowResponse {
    // message fields
    pub Rows: ::protobuf::RepeatedField<CreateFeedRowResponse_Row>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRowResponse {
    fn default() -> &'a CreateFeedRowResponse {
        <CreateFeedRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRowResponse {
    pub fn new() -> CreateFeedRowResponse {
        ::std::default::Default::default()
    }

    // repeated .feedapi.CreateFeedRowResponse.Row Rows = 1;


    pub fn get_Rows(&self) -> &[CreateFeedRowResponse_Row] {
        &self.Rows
    }
    pub fn clear_Rows(&mut self) {
        self.Rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rows(&mut self, v: ::protobuf::RepeatedField<CreateFeedRowResponse_Row>) {
        self.Rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rows(&mut self) -> &mut ::protobuf::RepeatedField<CreateFeedRowResponse_Row> {
        &mut self.Rows
    }

    // Take field
    pub fn take_Rows(&mut self) -> ::protobuf::RepeatedField<CreateFeedRowResponse_Row> {
        ::std::mem::replace(&mut self.Rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateFeedRowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Rows {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRowResponse {
        CreateFeedRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateFeedRowResponse_Row>>(
                    "Rows",
                    |m: &CreateFeedRowResponse| { &m.Rows },
                    |m: &mut CreateFeedRowResponse| { &mut m.Rows },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRowResponse>(
                    "CreateFeedRowResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFeedRowResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateFeedRowResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateFeedRowResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateFeedRowResponse {
    fn clear(&mut self) {
        self.Rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRowResponse_Row {
    // message fields
    pub Ok: bool,
    pub Error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRowResponse_Row {
    fn default() -> &'a CreateFeedRowResponse_Row {
        <CreateFeedRowResponse_Row as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRowResponse_Row {
    pub fn new() -> CreateFeedRowResponse_Row {
        ::std::default::Default::default()
    }

    // bool Ok = 1;


    pub fn get_Ok(&self) -> bool {
        self.Ok
    }
    pub fn clear_Ok(&mut self) {
        self.Ok = false;
    }

    // Param is passed by value, moved
    pub fn set_Ok(&mut self, v: bool) {
        self.Ok = v;
    }

    // .feedapi.Error Error = 2;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for CreateFeedRowResponse_Row {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ok = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Ok != false {
            os.write_bool(1, self.Ok)?;
        }
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRowResponse_Row {
        CreateFeedRowResponse_Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ok",
                    |m: &CreateFeedRowResponse_Row| { &m.Ok },
                    |m: &mut CreateFeedRowResponse_Row| { &mut m.Ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &CreateFeedRowResponse_Row| { &m.Error },
                    |m: &mut CreateFeedRowResponse_Row| { &mut m.Error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRowResponse_Row>(
                    "CreateFeedRowResponse.Row",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFeedRowResponse_Row {
        static mut instance: ::protobuf::lazy::Lazy<CreateFeedRowResponse_Row> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateFeedRowResponse_Row::new)
        }
    }
}

impl ::protobuf::Clear for CreateFeedRowResponse_Row {
    fn clear(&mut self) {
        self.Ok = false;
        self.Error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRowResponse_Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRowResponse_Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddStateToFeedRowRequest {
    // message fields
    pub AddStates: ::protobuf::RepeatedField<AddStateToFeedRowRequest_AddState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddStateToFeedRowRequest {
    fn default() -> &'a AddStateToFeedRowRequest {
        <AddStateToFeedRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddStateToFeedRowRequest {
    pub fn new() -> AddStateToFeedRowRequest {
        ::std::default::Default::default()
    }

    // repeated .feedapi.AddStateToFeedRowRequest.AddState AddStates = 1;


    pub fn get_AddStates(&self) -> &[AddStateToFeedRowRequest_AddState] {
        &self.AddStates
    }
    pub fn clear_AddStates(&mut self) {
        self.AddStates.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddStates(&mut self, v: ::protobuf::RepeatedField<AddStateToFeedRowRequest_AddState>) {
        self.AddStates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddStates(&mut self) -> &mut ::protobuf::RepeatedField<AddStateToFeedRowRequest_AddState> {
        &mut self.AddStates
    }

    // Take field
    pub fn take_AddStates(&mut self) -> ::protobuf::RepeatedField<AddStateToFeedRowRequest_AddState> {
        ::std::mem::replace(&mut self.AddStates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddStateToFeedRowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.AddStates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.AddStates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.AddStates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.AddStates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddStateToFeedRowRequest {
        AddStateToFeedRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddStateToFeedRowRequest_AddState>>(
                    "AddStates",
                    |m: &AddStateToFeedRowRequest| { &m.AddStates },
                    |m: &mut AddStateToFeedRowRequest| { &mut m.AddStates },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddStateToFeedRowRequest>(
                    "AddStateToFeedRowRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddStateToFeedRowRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddStateToFeedRowRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddStateToFeedRowRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddStateToFeedRowRequest {
    fn clear(&mut self) {
        self.AddStates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddStateToFeedRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddStateToFeedRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddStateToFeedRowRequest_AddState {
    // message fields
    pub FeedRowID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub State: ::protobuf::SingularPtrField<State>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddStateToFeedRowRequest_AddState {
    fn default() -> &'a AddStateToFeedRowRequest_AddState {
        <AddStateToFeedRowRequest_AddState as ::protobuf::Message>::default_instance()
    }
}

impl AddStateToFeedRowRequest_AddState {
    pub fn new() -> AddStateToFeedRowRequest_AddState {
        ::std::default::Default::default()
    }

    // string FeedRowID = 1;


    pub fn get_FeedRowID(&self) -> &str {
        &self.FeedRowID
    }
    pub fn clear_FeedRowID(&mut self) {
        self.FeedRowID.clear();
    }

    // Param is passed by value, moved
    pub fn set_FeedRowID(&mut self, v: ::std::string::String) {
        self.FeedRowID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeedRowID(&mut self) -> &mut ::std::string::String {
        &mut self.FeedRowID
    }

    // Take field
    pub fn take_FeedRowID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.FeedRowID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // .feedapi.State State = 3;


    pub fn get_State(&self) -> &State {
        self.State.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_State(&mut self) {
        self.State.clear();
    }

    pub fn has_State(&self) -> bool {
        self.State.is_some()
    }

    // Param is passed by value, moved
    pub fn set_State(&mut self, v: State) {
        self.State = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_State(&mut self) -> &mut State {
        if self.State.is_none() {
            self.State.set_default();
        }
        self.State.as_mut().unwrap()
    }

    // Take field
    pub fn take_State(&mut self) -> State {
        self.State.take().unwrap_or_else(|| State::new())
    }
}

impl ::protobuf::Message for AddStateToFeedRowRequest_AddState {
    fn is_initialized(&self) -> bool {
        for v in &self.State {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.FeedRowID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.State)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.FeedRowID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.FeedRowID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if let Some(ref v) = self.State.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.FeedRowID.is_empty() {
            os.write_string(1, &self.FeedRowID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if let Some(ref v) = self.State.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddStateToFeedRowRequest_AddState {
        AddStateToFeedRowRequest_AddState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "FeedRowID",
                    |m: &AddStateToFeedRowRequest_AddState| { &m.FeedRowID },
                    |m: &mut AddStateToFeedRowRequest_AddState| { &mut m.FeedRowID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &AddStateToFeedRowRequest_AddState| { &m.AccountID },
                    |m: &mut AddStateToFeedRowRequest_AddState| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "State",
                    |m: &AddStateToFeedRowRequest_AddState| { &m.State },
                    |m: &mut AddStateToFeedRowRequest_AddState| { &mut m.State },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddStateToFeedRowRequest_AddState>(
                    "AddStateToFeedRowRequest.AddState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddStateToFeedRowRequest_AddState {
        static mut instance: ::protobuf::lazy::Lazy<AddStateToFeedRowRequest_AddState> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddStateToFeedRowRequest_AddState::new)
        }
    }
}

impl ::protobuf::Clear for AddStateToFeedRowRequest_AddState {
    fn clear(&mut self) {
        self.FeedRowID.clear();
        self.AccountID.clear();
        self.State.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddStateToFeedRowRequest_AddState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddStateToFeedRowRequest_AddState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddStateToFeedRowResponse {
    // message fields
    pub AddStates: ::protobuf::RepeatedField<AddStateToFeedRowResponse_AddState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddStateToFeedRowResponse {
    fn default() -> &'a AddStateToFeedRowResponse {
        <AddStateToFeedRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddStateToFeedRowResponse {
    pub fn new() -> AddStateToFeedRowResponse {
        ::std::default::Default::default()
    }

    // repeated .feedapi.AddStateToFeedRowResponse.AddState AddStates = 1;


    pub fn get_AddStates(&self) -> &[AddStateToFeedRowResponse_AddState] {
        &self.AddStates
    }
    pub fn clear_AddStates(&mut self) {
        self.AddStates.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddStates(&mut self, v: ::protobuf::RepeatedField<AddStateToFeedRowResponse_AddState>) {
        self.AddStates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddStates(&mut self) -> &mut ::protobuf::RepeatedField<AddStateToFeedRowResponse_AddState> {
        &mut self.AddStates
    }

    // Take field
    pub fn take_AddStates(&mut self) -> ::protobuf::RepeatedField<AddStateToFeedRowResponse_AddState> {
        ::std::mem::replace(&mut self.AddStates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddStateToFeedRowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.AddStates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.AddStates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.AddStates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.AddStates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddStateToFeedRowResponse {
        AddStateToFeedRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddStateToFeedRowResponse_AddState>>(
                    "AddStates",
                    |m: &AddStateToFeedRowResponse| { &m.AddStates },
                    |m: &mut AddStateToFeedRowResponse| { &mut m.AddStates },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddStateToFeedRowResponse>(
                    "AddStateToFeedRowResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddStateToFeedRowResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddStateToFeedRowResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddStateToFeedRowResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddStateToFeedRowResponse {
    fn clear(&mut self) {
        self.AddStates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddStateToFeedRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddStateToFeedRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddStateToFeedRowResponse_AddState {
    // message fields
    pub Ok: bool,
    pub Error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddStateToFeedRowResponse_AddState {
    fn default() -> &'a AddStateToFeedRowResponse_AddState {
        <AddStateToFeedRowResponse_AddState as ::protobuf::Message>::default_instance()
    }
}

impl AddStateToFeedRowResponse_AddState {
    pub fn new() -> AddStateToFeedRowResponse_AddState {
        ::std::default::Default::default()
    }

    // bool Ok = 1;


    pub fn get_Ok(&self) -> bool {
        self.Ok
    }
    pub fn clear_Ok(&mut self) {
        self.Ok = false;
    }

    // Param is passed by value, moved
    pub fn set_Ok(&mut self, v: bool) {
        self.Ok = v;
    }

    // .feedapi.Error Error = 2;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for AddStateToFeedRowResponse_AddState {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ok = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Ok != false {
            os.write_bool(1, self.Ok)?;
        }
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddStateToFeedRowResponse_AddState {
        AddStateToFeedRowResponse_AddState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ok",
                    |m: &AddStateToFeedRowResponse_AddState| { &m.Ok },
                    |m: &mut AddStateToFeedRowResponse_AddState| { &mut m.Ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &AddStateToFeedRowResponse_AddState| { &m.Error },
                    |m: &mut AddStateToFeedRowResponse_AddState| { &mut m.Error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddStateToFeedRowResponse_AddState>(
                    "AddStateToFeedRowResponse.AddState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddStateToFeedRowResponse_AddState {
        static mut instance: ::protobuf::lazy::Lazy<AddStateToFeedRowResponse_AddState> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddStateToFeedRowResponse_AddState::new)
        }
    }
}

impl ::protobuf::Clear for AddStateToFeedRowResponse_AddState {
    fn clear(&mut self) {
        self.Ok = false;
        self.Error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddStateToFeedRowResponse_AddState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddStateToFeedRowResponse_AddState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRequest {
    // message fields
    pub Limit: i64,
    pub Offset: i64,
    pub AccountID: ::std::string::String,
    pub GroupID: ::std::string::String,
    pub StateParamFilter: ::protobuf::RepeatedField<GetFeedRequest_Filter>,
    pub Orders: ::protobuf::RepeatedField<GetFeedRequest_Order>,
    pub CurrentStateCode: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRequest {
    fn default() -> &'a GetFeedRequest {
        <GetFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRequest {
    pub fn new() -> GetFeedRequest {
        ::std::default::Default::default()
    }

    // int64 Limit = 1;


    pub fn get_Limit(&self) -> i64 {
        self.Limit
    }
    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: i64) {
        self.Limit = v;
    }

    // int64 Offset = 2;


    pub fn get_Offset(&self) -> i64 {
        self.Offset
    }
    pub fn clear_Offset(&mut self) {
        self.Offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_Offset(&mut self, v: i64) {
        self.Offset = v;
    }

    // string AccountID = 3;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // string GroupID = 4;


    pub fn get_GroupID(&self) -> &str {
        &self.GroupID
    }
    pub fn clear_GroupID(&mut self) {
        self.GroupID.clear();
    }

    // Param is passed by value, moved
    pub fn set_GroupID(&mut self, v: ::std::string::String) {
        self.GroupID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GroupID(&mut self) -> &mut ::std::string::String {
        &mut self.GroupID
    }

    // Take field
    pub fn take_GroupID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.GroupID, ::std::string::String::new())
    }

    // repeated .feedapi.GetFeedRequest.Filter StateParamFilter = 5;


    pub fn get_StateParamFilter(&self) -> &[GetFeedRequest_Filter] {
        &self.StateParamFilter
    }
    pub fn clear_StateParamFilter(&mut self) {
        self.StateParamFilter.clear();
    }

    // Param is passed by value, moved
    pub fn set_StateParamFilter(&mut self, v: ::protobuf::RepeatedField<GetFeedRequest_Filter>) {
        self.StateParamFilter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_StateParamFilter(&mut self) -> &mut ::protobuf::RepeatedField<GetFeedRequest_Filter> {
        &mut self.StateParamFilter
    }

    // Take field
    pub fn take_StateParamFilter(&mut self) -> ::protobuf::RepeatedField<GetFeedRequest_Filter> {
        ::std::mem::replace(&mut self.StateParamFilter, ::protobuf::RepeatedField::new())
    }

    // repeated .feedapi.GetFeedRequest.Order Orders = 6;


    pub fn get_Orders(&self) -> &[GetFeedRequest_Order] {
        &self.Orders
    }
    pub fn clear_Orders(&mut self) {
        self.Orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_Orders(&mut self, v: ::protobuf::RepeatedField<GetFeedRequest_Order>) {
        self.Orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Orders(&mut self) -> &mut ::protobuf::RepeatedField<GetFeedRequest_Order> {
        &mut self.Orders
    }

    // Take field
    pub fn take_Orders(&mut self) -> ::protobuf::RepeatedField<GetFeedRequest_Order> {
        ::std::mem::replace(&mut self.Orders, ::protobuf::RepeatedField::new())
    }

    // string CurrentStateCode = 7;


    pub fn get_CurrentStateCode(&self) -> &str {
        &self.CurrentStateCode
    }
    pub fn clear_CurrentStateCode(&mut self) {
        self.CurrentStateCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_CurrentStateCode(&mut self, v: ::std::string::String) {
        self.CurrentStateCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CurrentStateCode(&mut self) -> &mut ::std::string::String {
        &mut self.CurrentStateCode
    }

    // Take field
    pub fn take_CurrentStateCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CurrentStateCode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.StateParamFilter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Offset = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.GroupID)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.StateParamFilter)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Orders)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CurrentStateCode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.AccountID);
        }
        if !self.GroupID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.GroupID);
        }
        for value in &self.StateParamFilter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.CurrentStateCode.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.CurrentStateCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Limit != 0 {
            os.write_int64(1, self.Limit)?;
        }
        if self.Offset != 0 {
            os.write_int64(2, self.Offset)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(3, &self.AccountID)?;
        }
        if !self.GroupID.is_empty() {
            os.write_string(4, &self.GroupID)?;
        }
        for v in &self.StateParamFilter {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Orders {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.CurrentStateCode.is_empty() {
            os.write_string(7, &self.CurrentStateCode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRequest {
        GetFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Limit",
                    |m: &GetFeedRequest| { &m.Limit },
                    |m: &mut GetFeedRequest| { &mut m.Limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Offset",
                    |m: &GetFeedRequest| { &m.Offset },
                    |m: &mut GetFeedRequest| { &mut m.Offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &GetFeedRequest| { &m.AccountID },
                    |m: &mut GetFeedRequest| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "GroupID",
                    |m: &GetFeedRequest| { &m.GroupID },
                    |m: &mut GetFeedRequest| { &mut m.GroupID },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetFeedRequest_Filter>>(
                    "StateParamFilter",
                    |m: &GetFeedRequest| { &m.StateParamFilter },
                    |m: &mut GetFeedRequest| { &mut m.StateParamFilter },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetFeedRequest_Order>>(
                    "Orders",
                    |m: &GetFeedRequest| { &m.Orders },
                    |m: &mut GetFeedRequest| { &mut m.Orders },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "CurrentStateCode",
                    |m: &GetFeedRequest| { &m.CurrentStateCode },
                    |m: &mut GetFeedRequest| { &mut m.CurrentStateCode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRequest>(
                    "GetFeedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRequest {
    fn clear(&mut self) {
        self.Limit = 0;
        self.Offset = 0;
        self.AccountID.clear();
        self.GroupID.clear();
        self.StateParamFilter.clear();
        self.Orders.clear();
        self.CurrentStateCode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRequest_Filter {
    // message fields
    pub ParamName: ::std::string::String,
    pub ParamValue: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRequest_Filter {
    fn default() -> &'a GetFeedRequest_Filter {
        <GetFeedRequest_Filter as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRequest_Filter {
    pub fn new() -> GetFeedRequest_Filter {
        ::std::default::Default::default()
    }

    // string ParamName = 1;


    pub fn get_ParamName(&self) -> &str {
        &self.ParamName
    }
    pub fn clear_ParamName(&mut self) {
        self.ParamName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ParamName(&mut self, v: ::std::string::String) {
        self.ParamName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ParamName(&mut self) -> &mut ::std::string::String {
        &mut self.ParamName
    }

    // Take field
    pub fn take_ParamName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ParamName, ::std::string::String::new())
    }

    // string ParamValue = 2;


    pub fn get_ParamValue(&self) -> &str {
        &self.ParamValue
    }
    pub fn clear_ParamValue(&mut self) {
        self.ParamValue.clear();
    }

    // Param is passed by value, moved
    pub fn set_ParamValue(&mut self, v: ::std::string::String) {
        self.ParamValue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ParamValue(&mut self) -> &mut ::std::string::String {
        &mut self.ParamValue
    }

    // Take field
    pub fn take_ParamValue(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ParamValue, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeedRequest_Filter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ParamName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ParamValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ParamName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ParamName);
        }
        if !self.ParamValue.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ParamValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ParamName.is_empty() {
            os.write_string(1, &self.ParamName)?;
        }
        if !self.ParamValue.is_empty() {
            os.write_string(2, &self.ParamValue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRequest_Filter {
        GetFeedRequest_Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ParamName",
                    |m: &GetFeedRequest_Filter| { &m.ParamName },
                    |m: &mut GetFeedRequest_Filter| { &mut m.ParamName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ParamValue",
                    |m: &GetFeedRequest_Filter| { &m.ParamValue },
                    |m: &mut GetFeedRequest_Filter| { &mut m.ParamValue },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRequest_Filter>(
                    "GetFeedRequest.Filter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRequest_Filter {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRequest_Filter> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRequest_Filter::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRequest_Filter {
    fn clear(&mut self) {
        self.ParamName.clear();
        self.ParamValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRequest_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRequest_Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRequest_Order {
    // message fields
    pub ParamName: ::std::string::String,
    pub Dir: OrderDir,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRequest_Order {
    fn default() -> &'a GetFeedRequest_Order {
        <GetFeedRequest_Order as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRequest_Order {
    pub fn new() -> GetFeedRequest_Order {
        ::std::default::Default::default()
    }

    // string ParamName = 1;


    pub fn get_ParamName(&self) -> &str {
        &self.ParamName
    }
    pub fn clear_ParamName(&mut self) {
        self.ParamName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ParamName(&mut self, v: ::std::string::String) {
        self.ParamName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ParamName(&mut self) -> &mut ::std::string::String {
        &mut self.ParamName
    }

    // Take field
    pub fn take_ParamName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ParamName, ::std::string::String::new())
    }

    // .feedapi.OrderDir Dir = 2;


    pub fn get_Dir(&self) -> OrderDir {
        self.Dir
    }
    pub fn clear_Dir(&mut self) {
        self.Dir = OrderDir::Asc;
    }

    // Param is passed by value, moved
    pub fn set_Dir(&mut self, v: OrderDir) {
        self.Dir = v;
    }
}

impl ::protobuf::Message for GetFeedRequest_Order {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ParamName)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Dir, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ParamName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ParamName);
        }
        if self.Dir != OrderDir::Asc {
            my_size += ::protobuf::rt::enum_size(2, self.Dir);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ParamName.is_empty() {
            os.write_string(1, &self.ParamName)?;
        }
        if self.Dir != OrderDir::Asc {
            os.write_enum(2, self.Dir.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRequest_Order {
        GetFeedRequest_Order::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ParamName",
                    |m: &GetFeedRequest_Order| { &m.ParamName },
                    |m: &mut GetFeedRequest_Order| { &mut m.ParamName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OrderDir>>(
                    "Dir",
                    |m: &GetFeedRequest_Order| { &m.Dir },
                    |m: &mut GetFeedRequest_Order| { &mut m.Dir },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRequest_Order>(
                    "GetFeedRequest.Order",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRequest_Order {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRequest_Order> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRequest_Order::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRequest_Order {
    fn clear(&mut self) {
        self.ParamName.clear();
        self.Dir = OrderDir::Asc;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRequest_Order {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRequest_Order {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Contractor {
    // message fields
    pub ID: ::std::string::String,
    pub Params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Contractor {
    fn default() -> &'a Contractor {
        <Contractor as ::protobuf::Message>::default_instance()
    }
}

impl Contractor {
    pub fn new() -> Contractor {
        ::std::default::Default::default()
    }

    // string ID = 1;


    pub fn get_ID(&self) -> &str {
        &self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        &mut self.ID
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ID, ::std::string::String::new())
    }

    // repeated .feedapi.Contractor.ParamsEntry Params = 2;


    pub fn get_Params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.Params
    }
    pub fn clear_Params(&mut self) {
        self.Params.clear();
    }

    // Param is passed by value, moved
    pub fn set_Params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.Params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.Params
    }

    // Take field
    pub fn take_Params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.Params, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Contractor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ID)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.Params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ID);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.Params);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ID.is_empty() {
            os.write_string(1, &self.ID)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.Params, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Contractor {
        Contractor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ID",
                    |m: &Contractor| { &m.ID },
                    |m: &mut Contractor| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "Params",
                    |m: &Contractor| { &m.Params },
                    |m: &mut Contractor| { &mut m.Params },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Contractor>(
                    "Contractor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Contractor {
        static mut instance: ::protobuf::lazy::Lazy<Contractor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Contractor::new)
        }
    }
}

impl ::protobuf::Clear for Contractor {
    fn clear(&mut self) {
        self.ID.clear();
        self.Params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Contractor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Contractor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedResponse {
    // message fields
    pub Error: ::protobuf::SingularPtrField<Error>,
    pub Total: i64,
    pub Feed: ::protobuf::RepeatedField<GetFeedResponse_FeedRow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedResponse {
    fn default() -> &'a GetFeedResponse {
        <GetFeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedResponse {
    pub fn new() -> GetFeedResponse {
        ::std::default::Default::default()
    }

    // .feedapi.Error Error = 1;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }

    // int64 Total = 2;


    pub fn get_Total(&self) -> i64 {
        self.Total
    }
    pub fn clear_Total(&mut self) {
        self.Total = 0;
    }

    // Param is passed by value, moved
    pub fn set_Total(&mut self, v: i64) {
        self.Total = v;
    }

    // repeated .feedapi.GetFeedResponse.FeedRow Feed = 3;


    pub fn get_Feed(&self) -> &[GetFeedResponse_FeedRow] {
        &self.Feed
    }
    pub fn clear_Feed(&mut self) {
        self.Feed.clear();
    }

    // Param is passed by value, moved
    pub fn set_Feed(&mut self, v: ::protobuf::RepeatedField<GetFeedResponse_FeedRow>) {
        self.Feed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Feed(&mut self) -> &mut ::protobuf::RepeatedField<GetFeedResponse_FeedRow> {
        &mut self.Feed
    }

    // Take field
    pub fn take_Feed(&mut self) -> ::protobuf::RepeatedField<GetFeedResponse_FeedRow> {
        ::std::mem::replace(&mut self.Feed, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetFeedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Feed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Total = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Feed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Total != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Total, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Feed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Total != 0 {
            os.write_int64(2, self.Total)?;
        }
        for v in &self.Feed {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedResponse {
        GetFeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &GetFeedResponse| { &m.Error },
                    |m: &mut GetFeedResponse| { &mut m.Error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Total",
                    |m: &GetFeedResponse| { &m.Total },
                    |m: &mut GetFeedResponse| { &mut m.Total },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetFeedResponse_FeedRow>>(
                    "Feed",
                    |m: &GetFeedResponse| { &m.Feed },
                    |m: &mut GetFeedResponse| { &mut m.Feed },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedResponse>(
                    "GetFeedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedResponse {
    fn clear(&mut self) {
        self.Error.clear();
        self.Total = 0;
        self.Feed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedResponse_FeedRow {
    // message fields
    pub ID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub PartnerAccountID: ::std::string::String,
    pub CreatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub Contractor: ::protobuf::SingularPtrField<Contractor>,
    pub OperationType: ::std::string::String,
    pub OperationObjects: ::protobuf::RepeatedField<OperationObject>,
    pub Balance: ::protobuf::SingularPtrField<Balance>,
    pub CurrentState: ::protobuf::SingularPtrField<State>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedResponse_FeedRow {
    fn default() -> &'a GetFeedResponse_FeedRow {
        <GetFeedResponse_FeedRow as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedResponse_FeedRow {
    pub fn new() -> GetFeedResponse_FeedRow {
        ::std::default::Default::default()
    }

    // string ID = 1;


    pub fn get_ID(&self) -> &str {
        &self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        &mut self.ID
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // string PartnerAccountID = 3;


    pub fn get_PartnerAccountID(&self) -> &str {
        &self.PartnerAccountID
    }
    pub fn clear_PartnerAccountID(&mut self) {
        self.PartnerAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_PartnerAccountID(&mut self, v: ::std::string::String) {
        self.PartnerAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PartnerAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.PartnerAccountID
    }

    // Take field
    pub fn take_PartnerAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PartnerAccountID, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp CreatedAt = 4;


    pub fn get_CreatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.CreatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_CreatedAt(&mut self) {
        self.CreatedAt.clear();
    }

    pub fn has_CreatedAt(&self) -> bool {
        self.CreatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CreatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.CreatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.CreatedAt.is_none() {
            self.CreatedAt.set_default();
        }
        self.CreatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CreatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.CreatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .feedapi.Contractor Contractor = 5;


    pub fn get_Contractor(&self) -> &Contractor {
        self.Contractor.as_ref().unwrap_or_else(|| Contractor::default_instance())
    }
    pub fn clear_Contractor(&mut self) {
        self.Contractor.clear();
    }

    pub fn has_Contractor(&self) -> bool {
        self.Contractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Contractor(&mut self, v: Contractor) {
        self.Contractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Contractor(&mut self) -> &mut Contractor {
        if self.Contractor.is_none() {
            self.Contractor.set_default();
        }
        self.Contractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_Contractor(&mut self) -> Contractor {
        self.Contractor.take().unwrap_or_else(|| Contractor::new())
    }

    // string OperationType = 6;


    pub fn get_OperationType(&self) -> &str {
        &self.OperationType
    }
    pub fn clear_OperationType(&mut self) {
        self.OperationType.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationType(&mut self, v: ::std::string::String) {
        self.OperationType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OperationType(&mut self) -> &mut ::std::string::String {
        &mut self.OperationType
    }

    // Take field
    pub fn take_OperationType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.OperationType, ::std::string::String::new())
    }

    // repeated .feedapi.OperationObject OperationObjects = 7;


    pub fn get_OperationObjects(&self) -> &[OperationObject] {
        &self.OperationObjects
    }
    pub fn clear_OperationObjects(&mut self) {
        self.OperationObjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationObjects(&mut self, v: ::protobuf::RepeatedField<OperationObject>) {
        self.OperationObjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_OperationObjects(&mut self) -> &mut ::protobuf::RepeatedField<OperationObject> {
        &mut self.OperationObjects
    }

    // Take field
    pub fn take_OperationObjects(&mut self) -> ::protobuf::RepeatedField<OperationObject> {
        ::std::mem::replace(&mut self.OperationObjects, ::protobuf::RepeatedField::new())
    }

    // .feedapi.Balance Balance = 8;


    pub fn get_Balance(&self) -> &Balance {
        self.Balance.as_ref().unwrap_or_else(|| Balance::default_instance())
    }
    pub fn clear_Balance(&mut self) {
        self.Balance.clear();
    }

    pub fn has_Balance(&self) -> bool {
        self.Balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Balance(&mut self, v: Balance) {
        self.Balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Balance(&mut self) -> &mut Balance {
        if self.Balance.is_none() {
            self.Balance.set_default();
        }
        self.Balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_Balance(&mut self) -> Balance {
        self.Balance.take().unwrap_or_else(|| Balance::new())
    }

    // .feedapi.State CurrentState = 9;


    pub fn get_CurrentState(&self) -> &State {
        self.CurrentState.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_CurrentState(&mut self) {
        self.CurrentState.clear();
    }

    pub fn has_CurrentState(&self) -> bool {
        self.CurrentState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CurrentState(&mut self, v: State) {
        self.CurrentState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CurrentState(&mut self) -> &mut State {
        if self.CurrentState.is_none() {
            self.CurrentState.set_default();
        }
        self.CurrentState.as_mut().unwrap()
    }

    // Take field
    pub fn take_CurrentState(&mut self) -> State {
        self.CurrentState.take().unwrap_or_else(|| State::new())
    }
}

impl ::protobuf::Message for GetFeedResponse_FeedRow {
    fn is_initialized(&self) -> bool {
        for v in &self.CreatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Contractor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.OperationObjects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CurrentState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PartnerAccountID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CreatedAt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Contractor)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.OperationType)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.OperationObjects)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Balance)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CurrentState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if !self.PartnerAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.PartnerAccountID);
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Contractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.OperationType.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.OperationType);
        }
        for value in &self.OperationObjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CurrentState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ID.is_empty() {
            os.write_string(1, &self.ID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if !self.PartnerAccountID.is_empty() {
            os.write_string(3, &self.PartnerAccountID)?;
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Contractor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.OperationType.is_empty() {
            os.write_string(6, &self.OperationType)?;
        }
        for v in &self.OperationObjects {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CurrentState.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedResponse_FeedRow {
        GetFeedResponse_FeedRow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ID",
                    |m: &GetFeedResponse_FeedRow| { &m.ID },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &GetFeedResponse_FeedRow| { &m.AccountID },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PartnerAccountID",
                    |m: &GetFeedResponse_FeedRow| { &m.PartnerAccountID },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.PartnerAccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "CreatedAt",
                    |m: &GetFeedResponse_FeedRow| { &m.CreatedAt },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.CreatedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Contractor>>(
                    "Contractor",
                    |m: &GetFeedResponse_FeedRow| { &m.Contractor },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.Contractor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "OperationType",
                    |m: &GetFeedResponse_FeedRow| { &m.OperationType },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.OperationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationObject>>(
                    "OperationObjects",
                    |m: &GetFeedResponse_FeedRow| { &m.OperationObjects },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.OperationObjects },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Balance>>(
                    "Balance",
                    |m: &GetFeedResponse_FeedRow| { &m.Balance },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.Balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "CurrentState",
                    |m: &GetFeedResponse_FeedRow| { &m.CurrentState },
                    |m: &mut GetFeedResponse_FeedRow| { &mut m.CurrentState },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedResponse_FeedRow>(
                    "GetFeedResponse.FeedRow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedResponse_FeedRow {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedResponse_FeedRow> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedResponse_FeedRow::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedResponse_FeedRow {
    fn clear(&mut self) {
        self.ID.clear();
        self.AccountID.clear();
        self.PartnerAccountID.clear();
        self.CreatedAt.clear();
        self.Contractor.clear();
        self.OperationType.clear();
        self.OperationObjects.clear();
        self.Balance.clear();
        self.CurrentState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedResponse_FeedRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedResponse_FeedRow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRowRequest {
    // message fields
    pub FeedRowIDs: ::protobuf::RepeatedField<::std::string::String>,
    pub AccountID: ::std::string::String,
    pub IsRaw: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRowRequest {
    fn default() -> &'a GetFeedRowRequest {
        <GetFeedRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRowRequest {
    pub fn new() -> GetFeedRowRequest {
        ::std::default::Default::default()
    }

    // repeated string FeedRowIDs = 1;


    pub fn get_FeedRowIDs(&self) -> &[::std::string::String] {
        &self.FeedRowIDs
    }
    pub fn clear_FeedRowIDs(&mut self) {
        self.FeedRowIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_FeedRowIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.FeedRowIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_FeedRowIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.FeedRowIDs
    }

    // Take field
    pub fn take_FeedRowIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.FeedRowIDs, ::protobuf::RepeatedField::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // bool IsRaw = 3;


    pub fn get_IsRaw(&self) -> bool {
        self.IsRaw
    }
    pub fn clear_IsRaw(&mut self) {
        self.IsRaw = false;
    }

    // Param is passed by value, moved
    pub fn set_IsRaw(&mut self, v: bool) {
        self.IsRaw = v;
    }
}

impl ::protobuf::Message for GetFeedRowRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.FeedRowIDs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.IsRaw = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.FeedRowIDs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if self.IsRaw != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.FeedRowIDs {
            os.write_string(1, &v)?;
        };
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if self.IsRaw != false {
            os.write_bool(3, self.IsRaw)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRowRequest {
        GetFeedRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "FeedRowIDs",
                    |m: &GetFeedRowRequest| { &m.FeedRowIDs },
                    |m: &mut GetFeedRowRequest| { &mut m.FeedRowIDs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &GetFeedRowRequest| { &m.AccountID },
                    |m: &mut GetFeedRowRequest| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "IsRaw",
                    |m: &GetFeedRowRequest| { &m.IsRaw },
                    |m: &mut GetFeedRowRequest| { &mut m.IsRaw },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRowRequest>(
                    "GetFeedRowRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRowRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRowRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRowRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRowRequest {
    fn clear(&mut self) {
        self.FeedRowIDs.clear();
        self.AccountID.clear();
        self.IsRaw = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRowResponse {
    // message fields
    pub Rows: ::protobuf::RepeatedField<GetFeedRowResponse_Row>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRowResponse {
    fn default() -> &'a GetFeedRowResponse {
        <GetFeedRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRowResponse {
    pub fn new() -> GetFeedRowResponse {
        ::std::default::Default::default()
    }

    // repeated .feedapi.GetFeedRowResponse.Row Rows = 1;


    pub fn get_Rows(&self) -> &[GetFeedRowResponse_Row] {
        &self.Rows
    }
    pub fn clear_Rows(&mut self) {
        self.Rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rows(&mut self, v: ::protobuf::RepeatedField<GetFeedRowResponse_Row>) {
        self.Rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rows(&mut self) -> &mut ::protobuf::RepeatedField<GetFeedRowResponse_Row> {
        &mut self.Rows
    }

    // Take field
    pub fn take_Rows(&mut self) -> ::protobuf::RepeatedField<GetFeedRowResponse_Row> {
        ::std::mem::replace(&mut self.Rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetFeedRowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Rows {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRowResponse {
        GetFeedRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetFeedRowResponse_Row>>(
                    "Rows",
                    |m: &GetFeedRowResponse| { &m.Rows },
                    |m: &mut GetFeedRowResponse| { &mut m.Rows },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRowResponse>(
                    "GetFeedRowResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRowResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRowResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRowResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRowResponse {
    fn clear(&mut self) {
        self.Rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRowResponse_Row {
    // message fields
    pub Error: ::protobuf::SingularPtrField<Error>,
    pub ID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub PartnerAccountID: ::std::string::String,
    pub CreatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub Contractor: ::protobuf::SingularPtrField<Contractor>,
    pub OperationType: ::std::string::String,
    pub OperationObjects: ::protobuf::RepeatedField<OperationObject>,
    pub Balance: ::protobuf::SingularPtrField<Balance>,
    pub States: ::protobuf::RepeatedField<State>,
    pub StatesRaw: ::std::vec::Vec<u8>,
    pub CurrentState: ::protobuf::SingularPtrField<State>,
    pub Details: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRowResponse_Row {
    fn default() -> &'a GetFeedRowResponse_Row {
        <GetFeedRowResponse_Row as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRowResponse_Row {
    pub fn new() -> GetFeedRowResponse_Row {
        ::std::default::Default::default()
    }

    // .feedapi.Error Error = 1;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }

    // string ID = 2;


    pub fn get_ID(&self) -> &str {
        &self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        &mut self.ID
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ID, ::std::string::String::new())
    }

    // string AccountID = 3;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // string PartnerAccountID = 4;


    pub fn get_PartnerAccountID(&self) -> &str {
        &self.PartnerAccountID
    }
    pub fn clear_PartnerAccountID(&mut self) {
        self.PartnerAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_PartnerAccountID(&mut self, v: ::std::string::String) {
        self.PartnerAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PartnerAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.PartnerAccountID
    }

    // Take field
    pub fn take_PartnerAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PartnerAccountID, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp CreatedAt = 5;


    pub fn get_CreatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.CreatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_CreatedAt(&mut self) {
        self.CreatedAt.clear();
    }

    pub fn has_CreatedAt(&self) -> bool {
        self.CreatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CreatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.CreatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.CreatedAt.is_none() {
            self.CreatedAt.set_default();
        }
        self.CreatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CreatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.CreatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .feedapi.Contractor Contractor = 6;


    pub fn get_Contractor(&self) -> &Contractor {
        self.Contractor.as_ref().unwrap_or_else(|| Contractor::default_instance())
    }
    pub fn clear_Contractor(&mut self) {
        self.Contractor.clear();
    }

    pub fn has_Contractor(&self) -> bool {
        self.Contractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Contractor(&mut self, v: Contractor) {
        self.Contractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Contractor(&mut self) -> &mut Contractor {
        if self.Contractor.is_none() {
            self.Contractor.set_default();
        }
        self.Contractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_Contractor(&mut self) -> Contractor {
        self.Contractor.take().unwrap_or_else(|| Contractor::new())
    }

    // string OperationType = 7;


    pub fn get_OperationType(&self) -> &str {
        &self.OperationType
    }
    pub fn clear_OperationType(&mut self) {
        self.OperationType.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationType(&mut self, v: ::std::string::String) {
        self.OperationType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OperationType(&mut self) -> &mut ::std::string::String {
        &mut self.OperationType
    }

    // Take field
    pub fn take_OperationType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.OperationType, ::std::string::String::new())
    }

    // repeated .feedapi.OperationObject OperationObjects = 8;


    pub fn get_OperationObjects(&self) -> &[OperationObject] {
        &self.OperationObjects
    }
    pub fn clear_OperationObjects(&mut self) {
        self.OperationObjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationObjects(&mut self, v: ::protobuf::RepeatedField<OperationObject>) {
        self.OperationObjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_OperationObjects(&mut self) -> &mut ::protobuf::RepeatedField<OperationObject> {
        &mut self.OperationObjects
    }

    // Take field
    pub fn take_OperationObjects(&mut self) -> ::protobuf::RepeatedField<OperationObject> {
        ::std::mem::replace(&mut self.OperationObjects, ::protobuf::RepeatedField::new())
    }

    // .feedapi.Balance Balance = 9;


    pub fn get_Balance(&self) -> &Balance {
        self.Balance.as_ref().unwrap_or_else(|| Balance::default_instance())
    }
    pub fn clear_Balance(&mut self) {
        self.Balance.clear();
    }

    pub fn has_Balance(&self) -> bool {
        self.Balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Balance(&mut self, v: Balance) {
        self.Balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Balance(&mut self) -> &mut Balance {
        if self.Balance.is_none() {
            self.Balance.set_default();
        }
        self.Balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_Balance(&mut self) -> Balance {
        self.Balance.take().unwrap_or_else(|| Balance::new())
    }

    // repeated .feedapi.State States = 10;


    pub fn get_States(&self) -> &[State] {
        &self.States
    }
    pub fn clear_States(&mut self) {
        self.States.clear();
    }

    // Param is passed by value, moved
    pub fn set_States(&mut self, v: ::protobuf::RepeatedField<State>) {
        self.States = v;
    }

    // Mutable pointer to the field.
    pub fn mut_States(&mut self) -> &mut ::protobuf::RepeatedField<State> {
        &mut self.States
    }

    // Take field
    pub fn take_States(&mut self) -> ::protobuf::RepeatedField<State> {
        ::std::mem::replace(&mut self.States, ::protobuf::RepeatedField::new())
    }

    // bytes StatesRaw = 11;


    pub fn get_StatesRaw(&self) -> &[u8] {
        &self.StatesRaw
    }
    pub fn clear_StatesRaw(&mut self) {
        self.StatesRaw.clear();
    }

    // Param is passed by value, moved
    pub fn set_StatesRaw(&mut self, v: ::std::vec::Vec<u8>) {
        self.StatesRaw = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StatesRaw(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.StatesRaw
    }

    // Take field
    pub fn take_StatesRaw(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.StatesRaw, ::std::vec::Vec::new())
    }

    // .feedapi.State CurrentState = 12;


    pub fn get_CurrentState(&self) -> &State {
        self.CurrentState.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_CurrentState(&mut self) {
        self.CurrentState.clear();
    }

    pub fn has_CurrentState(&self) -> bool {
        self.CurrentState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CurrentState(&mut self, v: State) {
        self.CurrentState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CurrentState(&mut self) -> &mut State {
        if self.CurrentState.is_none() {
            self.CurrentState.set_default();
        }
        self.CurrentState.as_mut().unwrap()
    }

    // Take field
    pub fn take_CurrentState(&mut self) -> State {
        self.CurrentState.take().unwrap_or_else(|| State::new())
    }

    // bytes Details = 13;


    pub fn get_Details(&self) -> &[u8] {
        &self.Details
    }
    pub fn clear_Details(&mut self) {
        self.Details.clear();
    }

    // Param is passed by value, moved
    pub fn set_Details(&mut self, v: ::std::vec::Vec<u8>) {
        self.Details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Details(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Details
    }

    // Take field
    pub fn take_Details(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Details, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetFeedRowResponse_Row {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CreatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Contractor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.OperationObjects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.States {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CurrentState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PartnerAccountID)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CreatedAt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Contractor)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.OperationType)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.OperationObjects)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Balance)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.States)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.StatesRaw)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CurrentState)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.AccountID);
        }
        if !self.PartnerAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.PartnerAccountID);
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Contractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.OperationType.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.OperationType);
        }
        for value in &self.OperationObjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.States {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.StatesRaw.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.StatesRaw);
        }
        if let Some(ref v) = self.CurrentState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Details.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.Details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ID.is_empty() {
            os.write_string(2, &self.ID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(3, &self.AccountID)?;
        }
        if !self.PartnerAccountID.is_empty() {
            os.write_string(4, &self.PartnerAccountID)?;
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Contractor.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.OperationType.is_empty() {
            os.write_string(7, &self.OperationType)?;
        }
        for v in &self.OperationObjects {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Balance.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.States {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.StatesRaw.is_empty() {
            os.write_bytes(11, &self.StatesRaw)?;
        }
        if let Some(ref v) = self.CurrentState.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Details.is_empty() {
            os.write_bytes(13, &self.Details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRowResponse_Row {
        GetFeedRowResponse_Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &GetFeedRowResponse_Row| { &m.Error },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.Error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ID",
                    |m: &GetFeedRowResponse_Row| { &m.ID },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &GetFeedRowResponse_Row| { &m.AccountID },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PartnerAccountID",
                    |m: &GetFeedRowResponse_Row| { &m.PartnerAccountID },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.PartnerAccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "CreatedAt",
                    |m: &GetFeedRowResponse_Row| { &m.CreatedAt },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.CreatedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Contractor>>(
                    "Contractor",
                    |m: &GetFeedRowResponse_Row| { &m.Contractor },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.Contractor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "OperationType",
                    |m: &GetFeedRowResponse_Row| { &m.OperationType },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.OperationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationObject>>(
                    "OperationObjects",
                    |m: &GetFeedRowResponse_Row| { &m.OperationObjects },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.OperationObjects },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Balance>>(
                    "Balance",
                    |m: &GetFeedRowResponse_Row| { &m.Balance },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.Balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "States",
                    |m: &GetFeedRowResponse_Row| { &m.States },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.States },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "StatesRaw",
                    |m: &GetFeedRowResponse_Row| { &m.StatesRaw },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.StatesRaw },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "CurrentState",
                    |m: &GetFeedRowResponse_Row| { &m.CurrentState },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.CurrentState },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Details",
                    |m: &GetFeedRowResponse_Row| { &m.Details },
                    |m: &mut GetFeedRowResponse_Row| { &mut m.Details },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRowResponse_Row>(
                    "GetFeedRowResponse.Row",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeedRowResponse_Row {
        static mut instance: ::protobuf::lazy::Lazy<GetFeedRowResponse_Row> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetFeedRowResponse_Row::new)
        }
    }
}

impl ::protobuf::Clear for GetFeedRowResponse_Row {
    fn clear(&mut self) {
        self.Error.clear();
        self.ID.clear();
        self.AccountID.clear();
        self.PartnerAccountID.clear();
        self.CreatedAt.clear();
        self.Contractor.clear();
        self.OperationType.clear();
        self.OperationObjects.clear();
        self.Balance.clear();
        self.States.clear();
        self.StatesRaw.clear();
        self.CurrentState.clear();
        self.Details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRowResponse_Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRowResponse_Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContractorRequest {
    // message fields
    pub Contractor: ::protobuf::SingularPtrField<Contractor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContractorRequest {
    fn default() -> &'a CreateContractorRequest {
        <CreateContractorRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContractorRequest {
    pub fn new() -> CreateContractorRequest {
        ::std::default::Default::default()
    }

    // .feedapi.Contractor Contractor = 1;


    pub fn get_Contractor(&self) -> &Contractor {
        self.Contractor.as_ref().unwrap_or_else(|| Contractor::default_instance())
    }
    pub fn clear_Contractor(&mut self) {
        self.Contractor.clear();
    }

    pub fn has_Contractor(&self) -> bool {
        self.Contractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Contractor(&mut self, v: Contractor) {
        self.Contractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Contractor(&mut self) -> &mut Contractor {
        if self.Contractor.is_none() {
            self.Contractor.set_default();
        }
        self.Contractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_Contractor(&mut self) -> Contractor {
        self.Contractor.take().unwrap_or_else(|| Contractor::new())
    }
}

impl ::protobuf::Message for CreateContractorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Contractor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Contractor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Contractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Contractor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContractorRequest {
        CreateContractorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Contractor>>(
                    "Contractor",
                    |m: &CreateContractorRequest| { &m.Contractor },
                    |m: &mut CreateContractorRequest| { &mut m.Contractor },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContractorRequest>(
                    "CreateContractorRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateContractorRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateContractorRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateContractorRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateContractorRequest {
    fn clear(&mut self) {
        self.Contractor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContractorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContractorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContractorResponse {
    // message fields
    pub Error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContractorResponse {
    fn default() -> &'a CreateContractorResponse {
        <CreateContractorResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateContractorResponse {
    pub fn new() -> CreateContractorResponse {
        ::std::default::Default::default()
    }

    // .feedapi.Error Error = 1;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for CreateContractorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContractorResponse {
        CreateContractorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &CreateContractorResponse| { &m.Error },
                    |m: &mut CreateContractorResponse| { &mut m.Error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContractorResponse>(
                    "CreateContractorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateContractorResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateContractorResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateContractorResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateContractorResponse {
    fn clear(&mut self) {
        self.Error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContractorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContractorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContractorRequest {
    // message fields
    pub Contractor: ::protobuf::SingularPtrField<Contractor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContractorRequest {
    fn default() -> &'a UpdateContractorRequest {
        <UpdateContractorRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContractorRequest {
    pub fn new() -> UpdateContractorRequest {
        ::std::default::Default::default()
    }

    // .feedapi.Contractor Contractor = 1;


    pub fn get_Contractor(&self) -> &Contractor {
        self.Contractor.as_ref().unwrap_or_else(|| Contractor::default_instance())
    }
    pub fn clear_Contractor(&mut self) {
        self.Contractor.clear();
    }

    pub fn has_Contractor(&self) -> bool {
        self.Contractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Contractor(&mut self, v: Contractor) {
        self.Contractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Contractor(&mut self) -> &mut Contractor {
        if self.Contractor.is_none() {
            self.Contractor.set_default();
        }
        self.Contractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_Contractor(&mut self) -> Contractor {
        self.Contractor.take().unwrap_or_else(|| Contractor::new())
    }
}

impl ::protobuf::Message for UpdateContractorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Contractor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Contractor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Contractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Contractor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContractorRequest {
        UpdateContractorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Contractor>>(
                    "Contractor",
                    |m: &UpdateContractorRequest| { &m.Contractor },
                    |m: &mut UpdateContractorRequest| { &mut m.Contractor },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateContractorRequest>(
                    "UpdateContractorRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateContractorRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateContractorRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateContractorRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateContractorRequest {
    fn clear(&mut self) {
        self.Contractor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContractorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContractorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContractorResponse {
    // message fields
    pub Error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContractorResponse {
    fn default() -> &'a UpdateContractorResponse {
        <UpdateContractorResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContractorResponse {
    pub fn new() -> UpdateContractorResponse {
        ::std::default::Default::default()
    }

    // .feedapi.Error Error = 1;


    pub fn get_Error(&self) -> &Error {
        self.Error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_Error(&mut self) {
        self.Error.clear();
    }

    pub fn has_Error(&self) -> bool {
        self.Error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Error(&mut self, v: Error) {
        self.Error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Error(&mut self) -> &mut Error {
        if self.Error.is_none() {
            self.Error.set_default();
        }
        self.Error.as_mut().unwrap()
    }

    // Take field
    pub fn take_Error(&mut self) -> Error {
        self.Error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for UpdateContractorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContractorResponse {
        UpdateContractorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "Error",
                    |m: &UpdateContractorResponse| { &m.Error },
                    |m: &mut UpdateContractorResponse| { &mut m.Error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateContractorResponse>(
                    "UpdateContractorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateContractorResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateContractorResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateContractorResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateContractorResponse {
    fn clear(&mut self) {
        self.Error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContractorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContractorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContractorsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContractorsRequest {
    fn default() -> &'a GetContractorsRequest {
        <GetContractorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetContractorsRequest {
    pub fn new() -> GetContractorsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetContractorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContractorsRequest {
        GetContractorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContractorsRequest>(
                    "GetContractorsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContractorsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetContractorsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetContractorsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetContractorsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContractorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContractorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContractorsResponse {
    // message fields
    pub Contractors: ::protobuf::RepeatedField<Contractor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContractorsResponse {
    fn default() -> &'a GetContractorsResponse {
        <GetContractorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetContractorsResponse {
    pub fn new() -> GetContractorsResponse {
        ::std::default::Default::default()
    }

    // repeated .feedapi.Contractor Contractors = 1;


    pub fn get_Contractors(&self) -> &[Contractor] {
        &self.Contractors
    }
    pub fn clear_Contractors(&mut self) {
        self.Contractors.clear();
    }

    // Param is passed by value, moved
    pub fn set_Contractors(&mut self, v: ::protobuf::RepeatedField<Contractor>) {
        self.Contractors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Contractors(&mut self) -> &mut ::protobuf::RepeatedField<Contractor> {
        &mut self.Contractors
    }

    // Take field
    pub fn take_Contractors(&mut self) -> ::protobuf::RepeatedField<Contractor> {
        ::std::mem::replace(&mut self.Contractors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetContractorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Contractors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Contractors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Contractors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Contractors {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContractorsResponse {
        GetContractorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Contractor>>(
                    "Contractors",
                    |m: &GetContractorsResponse| { &m.Contractors },
                    |m: &mut GetContractorsResponse| { &mut m.Contractors },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContractorsResponse>(
                    "GetContractorsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContractorsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetContractorsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetContractorsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetContractorsResponse {
    fn clear(&mut self) {
        self.Contractors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContractorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContractorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HaveSeenRequest {
    // message fields
    pub AccountID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HaveSeenRequest {
    fn default() -> &'a HaveSeenRequest {
        <HaveSeenRequest as ::protobuf::Message>::default_instance()
    }
}

impl HaveSeenRequest {
    pub fn new() -> HaveSeenRequest {
        ::std::default::Default::default()
    }

    // string AccountID = 1;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HaveSeenRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.AccountID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.AccountID.is_empty() {
            os.write_string(1, &self.AccountID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HaveSeenRequest {
        HaveSeenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &HaveSeenRequest| { &m.AccountID },
                    |m: &mut HaveSeenRequest| { &mut m.AccountID },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HaveSeenRequest>(
                    "HaveSeenRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HaveSeenRequest {
        static mut instance: ::protobuf::lazy::Lazy<HaveSeenRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HaveSeenRequest::new)
        }
    }
}

impl ::protobuf::Clear for HaveSeenRequest {
    fn clear(&mut self) {
        self.AccountID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HaveSeenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HaveSeenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HaveSeenResponse {
    // message fields
    pub Is: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HaveSeenResponse {
    fn default() -> &'a HaveSeenResponse {
        <HaveSeenResponse as ::protobuf::Message>::default_instance()
    }
}

impl HaveSeenResponse {
    pub fn new() -> HaveSeenResponse {
        ::std::default::Default::default()
    }

    // bool Is = 1;


    pub fn get_Is(&self) -> bool {
        self.Is
    }
    pub fn clear_Is(&mut self) {
        self.Is = false;
    }

    // Param is passed by value, moved
    pub fn set_Is(&mut self, v: bool) {
        self.Is = v;
    }
}

impl ::protobuf::Message for HaveSeenResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Is = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Is != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Is != false {
            os.write_bool(1, self.Is)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HaveSeenResponse {
        HaveSeenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Is",
                    |m: &HaveSeenResponse| { &m.Is },
                    |m: &mut HaveSeenResponse| { &mut m.Is },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HaveSeenResponse>(
                    "HaveSeenResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HaveSeenResponse {
        static mut instance: ::protobuf::lazy::Lazy<HaveSeenResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HaveSeenResponse::new)
        }
    }
}

impl ::protobuf::Clear for HaveSeenResponse {
    fn clear(&mut self) {
        self.Is = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HaveSeenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HaveSeenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeenRequest {
    // message fields
    pub AccountID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeenRequest {
    fn default() -> &'a SeenRequest {
        <SeenRequest as ::protobuf::Message>::default_instance()
    }
}

impl SeenRequest {
    pub fn new() -> SeenRequest {
        ::std::default::Default::default()
    }

    // string AccountID = 1;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SeenRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.AccountID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.AccountID.is_empty() {
            os.write_string(1, &self.AccountID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeenRequest {
        SeenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &SeenRequest| { &m.AccountID },
                    |m: &mut SeenRequest| { &mut m.AccountID },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeenRequest>(
                    "SeenRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SeenRequest {
        static mut instance: ::protobuf::lazy::Lazy<SeenRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SeenRequest::new)
        }
    }
}

impl ::protobuf::Clear for SeenRequest {
    fn clear(&mut self) {
        self.AccountID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeenResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeenResponse {
    fn default() -> &'a SeenResponse {
        <SeenResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeenResponse {
    pub fn new() -> SeenResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SeenResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeenResponse {
        SeenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeenResponse>(
                    "SeenResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SeenResponse {
        static mut instance: ::protobuf::lazy::Lazy<SeenResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SeenResponse::new)
        }
    }
}

impl ::protobuf::Clear for SeenResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub Code: ErrorCode,
    pub Message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // .feedapi.ErrorCode Code = 1;


    pub fn get_Code(&self) -> ErrorCode {
        self.Code
    }
    pub fn clear_Code(&mut self) {
        self.Code = ErrorCode::UndefinedError;
    }

    // Param is passed by value, moved
    pub fn set_Code(&mut self, v: ErrorCode) {
        self.Code = v;
    }

    // string Message = 2;


    pub fn get_Message(&self) -> &str {
        &self.Message
    }
    pub fn clear_Message(&mut self) {
        self.Message.clear();
    }

    // Param is passed by value, moved
    pub fn set_Message(&mut self, v: ::std::string::String) {
        self.Message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Message(&mut self) -> &mut ::std::string::String {
        &mut self.Message
    }

    // Take field
    pub fn take_Message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Code != ErrorCode::UndefinedError {
            my_size += ::protobuf::rt::enum_size(1, self.Code);
        }
        if !self.Message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Code != ErrorCode::UndefinedError {
            os.write_enum(1, self.Code.value())?;
        }
        if !self.Message.is_empty() {
            os.write_string(2, &self.Message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrorCode>>(
                    "Code",
                    |m: &Error| { &m.Code },
                    |m: &mut Error| { &mut m.Code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Message",
                    |m: &Error| { &m.Message },
                    |m: &mut Error| { &mut m.Message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.Code = ErrorCode::UndefinedError;
        self.Message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncFeedRowCreatedEvent {
    // message fields
    pub FeedRowID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub CreatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub OperationType: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncFeedRowCreatedEvent {
    fn default() -> &'a AsyncFeedRowCreatedEvent {
        <AsyncFeedRowCreatedEvent as ::protobuf::Message>::default_instance()
    }
}

impl AsyncFeedRowCreatedEvent {
    pub fn new() -> AsyncFeedRowCreatedEvent {
        ::std::default::Default::default()
    }

    // string FeedRowID = 1;


    pub fn get_FeedRowID(&self) -> &str {
        &self.FeedRowID
    }
    pub fn clear_FeedRowID(&mut self) {
        self.FeedRowID.clear();
    }

    // Param is passed by value, moved
    pub fn set_FeedRowID(&mut self, v: ::std::string::String) {
        self.FeedRowID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeedRowID(&mut self) -> &mut ::std::string::String {
        &mut self.FeedRowID
    }

    // Take field
    pub fn take_FeedRowID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.FeedRowID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp CreatedAt = 3;


    pub fn get_CreatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.CreatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_CreatedAt(&mut self) {
        self.CreatedAt.clear();
    }

    pub fn has_CreatedAt(&self) -> bool {
        self.CreatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CreatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.CreatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.CreatedAt.is_none() {
            self.CreatedAt.set_default();
        }
        self.CreatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CreatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.CreatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string OperationType = 4;


    pub fn get_OperationType(&self) -> &str {
        &self.OperationType
    }
    pub fn clear_OperationType(&mut self) {
        self.OperationType.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationType(&mut self, v: ::std::string::String) {
        self.OperationType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OperationType(&mut self) -> &mut ::std::string::String {
        &mut self.OperationType
    }

    // Take field
    pub fn take_OperationType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.OperationType, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AsyncFeedRowCreatedEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.CreatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.FeedRowID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CreatedAt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.OperationType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.FeedRowID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.FeedRowID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.OperationType.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.OperationType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.FeedRowID.is_empty() {
            os.write_string(1, &self.FeedRowID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if let Some(ref v) = self.CreatedAt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.OperationType.is_empty() {
            os.write_string(4, &self.OperationType)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncFeedRowCreatedEvent {
        AsyncFeedRowCreatedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "FeedRowID",
                    |m: &AsyncFeedRowCreatedEvent| { &m.FeedRowID },
                    |m: &mut AsyncFeedRowCreatedEvent| { &mut m.FeedRowID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &AsyncFeedRowCreatedEvent| { &m.AccountID },
                    |m: &mut AsyncFeedRowCreatedEvent| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "CreatedAt",
                    |m: &AsyncFeedRowCreatedEvent| { &m.CreatedAt },
                    |m: &mut AsyncFeedRowCreatedEvent| { &mut m.CreatedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "OperationType",
                    |m: &AsyncFeedRowCreatedEvent| { &m.OperationType },
                    |m: &mut AsyncFeedRowCreatedEvent| { &mut m.OperationType },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncFeedRowCreatedEvent>(
                    "AsyncFeedRowCreatedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsyncFeedRowCreatedEvent {
        static mut instance: ::protobuf::lazy::Lazy<AsyncFeedRowCreatedEvent> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AsyncFeedRowCreatedEvent::new)
        }
    }
}

impl ::protobuf::Clear for AsyncFeedRowCreatedEvent {
    fn clear(&mut self) {
        self.FeedRowID.clear();
        self.AccountID.clear();
        self.CreatedAt.clear();
        self.OperationType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncFeedRowCreatedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncFeedRowCreatedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncFeedRowUpdatedEvent {
    // message fields
    pub FeedRowID: ::std::string::String,
    pub AccountID: ::std::string::String,
    pub State: ::protobuf::SingularPtrField<State>,
    pub UpdatedAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub OperationType: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncFeedRowUpdatedEvent {
    fn default() -> &'a AsyncFeedRowUpdatedEvent {
        <AsyncFeedRowUpdatedEvent as ::protobuf::Message>::default_instance()
    }
}

impl AsyncFeedRowUpdatedEvent {
    pub fn new() -> AsyncFeedRowUpdatedEvent {
        ::std::default::Default::default()
    }

    // string FeedRowID = 1;


    pub fn get_FeedRowID(&self) -> &str {
        &self.FeedRowID
    }
    pub fn clear_FeedRowID(&mut self) {
        self.FeedRowID.clear();
    }

    // Param is passed by value, moved
    pub fn set_FeedRowID(&mut self, v: ::std::string::String) {
        self.FeedRowID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeedRowID(&mut self) -> &mut ::std::string::String {
        &mut self.FeedRowID
    }

    // Take field
    pub fn take_FeedRowID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.FeedRowID, ::std::string::String::new())
    }

    // string AccountID = 2;


    pub fn get_AccountID(&self) -> &str {
        &self.AccountID
    }
    pub fn clear_AccountID(&mut self) {
        self.AccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccountID(&mut self, v: ::std::string::String) {
        self.AccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccountID(&mut self) -> &mut ::std::string::String {
        &mut self.AccountID
    }

    // Take field
    pub fn take_AccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccountID, ::std::string::String::new())
    }

    // .feedapi.State State = 3;


    pub fn get_State(&self) -> &State {
        self.State.as_ref().unwrap_or_else(|| State::default_instance())
    }
    pub fn clear_State(&mut self) {
        self.State.clear();
    }

    pub fn has_State(&self) -> bool {
        self.State.is_some()
    }

    // Param is passed by value, moved
    pub fn set_State(&mut self, v: State) {
        self.State = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_State(&mut self) -> &mut State {
        if self.State.is_none() {
            self.State.set_default();
        }
        self.State.as_mut().unwrap()
    }

    // Take field
    pub fn take_State(&mut self) -> State {
        self.State.take().unwrap_or_else(|| State::new())
    }

    // .google.protobuf.Timestamp UpdatedAt = 4;


    pub fn get_UpdatedAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.UpdatedAt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_UpdatedAt(&mut self) {
        self.UpdatedAt.clear();
    }

    pub fn has_UpdatedAt(&self) -> bool {
        self.UpdatedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_UpdatedAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.UpdatedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_UpdatedAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.UpdatedAt.is_none() {
            self.UpdatedAt.set_default();
        }
        self.UpdatedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_UpdatedAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.UpdatedAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string OperationType = 5;


    pub fn get_OperationType(&self) -> &str {
        &self.OperationType
    }
    pub fn clear_OperationType(&mut self) {
        self.OperationType.clear();
    }

    // Param is passed by value, moved
    pub fn set_OperationType(&mut self, v: ::std::string::String) {
        self.OperationType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OperationType(&mut self) -> &mut ::std::string::String {
        &mut self.OperationType
    }

    // Take field
    pub fn take_OperationType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.OperationType, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AsyncFeedRowUpdatedEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.State {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.UpdatedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.FeedRowID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.State)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.UpdatedAt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.OperationType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.FeedRowID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.FeedRowID);
        }
        if !self.AccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.AccountID);
        }
        if let Some(ref v) = self.State.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.UpdatedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.OperationType.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.OperationType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.FeedRowID.is_empty() {
            os.write_string(1, &self.FeedRowID)?;
        }
        if !self.AccountID.is_empty() {
            os.write_string(2, &self.AccountID)?;
        }
        if let Some(ref v) = self.State.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.UpdatedAt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.OperationType.is_empty() {
            os.write_string(5, &self.OperationType)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncFeedRowUpdatedEvent {
        AsyncFeedRowUpdatedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "FeedRowID",
                    |m: &AsyncFeedRowUpdatedEvent| { &m.FeedRowID },
                    |m: &mut AsyncFeedRowUpdatedEvent| { &mut m.FeedRowID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "AccountID",
                    |m: &AsyncFeedRowUpdatedEvent| { &m.AccountID },
                    |m: &mut AsyncFeedRowUpdatedEvent| { &mut m.AccountID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<State>>(
                    "State",
                    |m: &AsyncFeedRowUpdatedEvent| { &m.State },
                    |m: &mut AsyncFeedRowUpdatedEvent| { &mut m.State },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "UpdatedAt",
                    |m: &AsyncFeedRowUpdatedEvent| { &m.UpdatedAt },
                    |m: &mut AsyncFeedRowUpdatedEvent| { &mut m.UpdatedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "OperationType",
                    |m: &AsyncFeedRowUpdatedEvent| { &m.OperationType },
                    |m: &mut AsyncFeedRowUpdatedEvent| { &mut m.OperationType },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncFeedRowUpdatedEvent>(
                    "AsyncFeedRowUpdatedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsyncFeedRowUpdatedEvent {
        static mut instance: ::protobuf::lazy::Lazy<AsyncFeedRowUpdatedEvent> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AsyncFeedRowUpdatedEvent::new)
        }
    }
}

impl ::protobuf::Clear for AsyncFeedRowUpdatedEvent {
    fn clear(&mut self) {
        self.FeedRowID.clear();
        self.AccountID.clear();
        self.State.clear();
        self.UpdatedAt.clear();
        self.OperationType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncFeedRowUpdatedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncFeedRowUpdatedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorCode {
    UndefinedError = 0,
    ValidationError = 1,
    StateNotFound = 2,
    FeedRowExists = 3,
    ContractorNotFound = 4,
    FeedRowNotFound = 5,
}

impl ::protobuf::ProtobufEnum for ErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ErrorCode::UndefinedError),
            1 => ::std::option::Option::Some(ErrorCode::ValidationError),
            2 => ::std::option::Option::Some(ErrorCode::StateNotFound),
            3 => ::std::option::Option::Some(ErrorCode::FeedRowExists),
            4 => ::std::option::Option::Some(ErrorCode::ContractorNotFound),
            5 => ::std::option::Option::Some(ErrorCode::FeedRowNotFound),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorCode] = &[
            ErrorCode::UndefinedError,
            ErrorCode::ValidationError,
            ErrorCode::StateNotFound,
            ErrorCode::FeedRowExists,
            ErrorCode::ContractorNotFound,
            ErrorCode::FeedRowNotFound,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrorCode>("ErrorCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ErrorCode {
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        ErrorCode::UndefinedError
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderDir {
    Asc = 0,
    Desc = 1,
}

impl ::protobuf::ProtobufEnum for OrderDir {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderDir> {
        match value {
            0 => ::std::option::Option::Some(OrderDir::Asc),
            1 => ::std::option::Option::Some(OrderDir::Desc),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderDir] = &[
            OrderDir::Asc,
            OrderDir::Desc,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<OrderDir>("OrderDir", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OrderDir {
}

impl ::std::default::Default for OrderDir {
    fn default() -> Self {
        OrderDir::Asc
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderDir {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rfeedapi.proto\x12\x07feedapi\x1a\x1fgoogle/protobuf/timestamp.proto\
    \"}\n\x05State\x12\x0e\n\x02ID\x18\x01\x20\x01(\tR\x02ID\x12\x12\n\x04Co\
    de\x18\x02\x20\x01(\tR\x04Code\x12\x16\n\x06Params\x18\x03\x20\x01(\x0cR\
    \x06Params\x128\n\tCreatedAt\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\tCreatedAt\"v\n\x12UpdateStateRequest\x12\x1c\n\tFeedRowID\x18\
    \x01\x20\x01(\tR\tFeedRowID\x12\x1c\n\tAccountID\x18\x02\x20\x01(\tR\tAc\
    countID\x12$\n\x05State\x18\x03\x20\x01(\x0b2\x0e.feedapi.StateR\x05Stat\
    e\";\n\x13UpdateStateResponse\x12$\n\x05Error\x18\x01\x20\x01(\x0b2\x0e.\
    feedapi.ErrorR\x05Error\"s\n\x07Balance\x12\x12\n\x04Type\x18\x01\x20\
    \x01(\tR\x04Type\x12\x16\n\x06Amount\x18\x02\x20\x01(\x03R\x06Amount\x12\
    \x1c\n\tAssetType\x18\x03\x20\x01(\tR\tAssetType\x12\x1e\n\nAssetTitle\
    \x18\x04\x20\x01(\tR\nAssetTitle\"]\n\x0fOperationObject\x12\x0e\n\x02ID\
    \x18\x01\x20\x01(\tR\x02ID\x12\x14\n\x05Title\x18\x02\x20\x01(\tR\x05Tit\
    le\x12\x10\n\x03Url\x18\x03\x20\x01(\tR\x03Url\x12\x12\n\x04Meta\x18\x04\
    \x20\x01(\x0cR\x04Meta\"\x85\x04\n\x14CreateFeedRowRequest\x125\n\x04Row\
    s\x18\x01\x20\x03(\x0b2!.feedapi.CreateFeedRowRequest.RowR\x04Rows\x1a\
    \xb5\x03\n\x03Row\x12\x14\n\x05RowID\x18\x01\x20\x01(\tR\x05RowID\x12\
    \x1c\n\tAccountID\x18\x02\x20\x01(\tR\tAccountID\x12*\n\x10PartnerAccoun\
    tID\x18\x03\x20\x01(\tR\x10PartnerAccountID\x12\x18\n\x07GroupID\x18\x04\
    \x20\x01(\tR\x07GroupID\x128\n\tCreatedAt\x18\x05\x20\x01(\x0b2\x1a.goog\
    le.protobuf.TimestampR\tCreatedAt\x12$\n\rOperationType\x18\x06\x20\x01(\
    \tR\rOperationType\x12D\n\x10OperationObjects\x18\x07\x20\x03(\x0b2\x18.\
    feedapi.OperationObjectR\x10OperationObjects\x12*\n\x07Balance\x18\x08\
    \x20\x01(\x0b2\x10.feedapi.BalanceR\x07Balance\x12\"\n\x0cContractorID\
    \x18\t\x20\x01(\tR\x0cContractorID\x12$\n\x05State\x18\n\x20\x01(\x0b2\
    \x0e.feedapi.StateR\x05State\x12\x18\n\x07Details\x18\x0b\x20\x01(\x0cR\
    \x07Details\"\x8c\x01\n\x15CreateFeedRowResponse\x126\n\x04Rows\x18\x01\
    \x20\x03(\x0b2\".feedapi.CreateFeedRowResponse.RowR\x04Rows\x1a;\n\x03Ro\
    w\x12\x0e\n\x02Ok\x18\x01\x20\x01(\x08R\x02Ok\x12$\n\x05Error\x18\x02\
    \x20\x01(\x0b2\x0e.feedapi.ErrorR\x05Error\"\xd2\x01\n\x18AddStateToFeed\
    RowRequest\x12H\n\tAddStates\x18\x01\x20\x03(\x0b2*.feedapi.AddStateToFe\
    edRowRequest.AddStateR\tAddStates\x1al\n\x08AddState\x12\x1c\n\tFeedRowI\
    D\x18\x01\x20\x01(\tR\tFeedRowID\x12\x1c\n\tAccountID\x18\x02\x20\x01(\t\
    R\tAccountID\x12$\n\x05State\x18\x03\x20\x01(\x0b2\x0e.feedapi.StateR\
    \x05State\"\xa8\x01\n\x19AddStateToFeedRowResponse\x12I\n\tAddStates\x18\
    \x01\x20\x03(\x0b2+.feedapi.AddStateToFeedRowResponse.AddStateR\tAddStat\
    es\x1a@\n\x08AddState\x12\x0e\n\x02Ok\x18\x01\x20\x01(\x08R\x02Ok\x12$\n\
    \x05Error\x18\x02\x20\x01(\x0b2\x0e.feedapi.ErrorR\x05Error\"\xb9\x03\n\
    \x0eGetFeedRequest\x12\x14\n\x05Limit\x18\x01\x20\x01(\x03R\x05Limit\x12\
    \x16\n\x06Offset\x18\x02\x20\x01(\x03R\x06Offset\x12\x1c\n\tAccountID\
    \x18\x03\x20\x01(\tR\tAccountID\x12\x18\n\x07GroupID\x18\x04\x20\x01(\tR\
    \x07GroupID\x12J\n\x10StateParamFilter\x18\x05\x20\x03(\x0b2\x1e.feedapi\
    .GetFeedRequest.FilterR\x10StateParamFilter\x125\n\x06Orders\x18\x06\x20\
    \x03(\x0b2\x1d.feedapi.GetFeedRequest.OrderR\x06Orders\x12*\n\x10Current\
    StateCode\x18\x07\x20\x01(\tR\x10CurrentStateCode\x1aF\n\x06Filter\x12\
    \x1c\n\tParamName\x18\x01\x20\x01(\tR\tParamName\x12\x1e\n\nParamValue\
    \x18\x02\x20\x01(\tR\nParamValue\x1aJ\n\x05Order\x12\x1c\n\tParamName\
    \x18\x01\x20\x01(\tR\tParamName\x12#\n\x03Dir\x18\x02\x20\x01(\x0e2\x11.\
    feedapi.OrderDirR\x03Dir\"\x90\x01\n\nContractor\x12\x0e\n\x02ID\x18\x01\
    \x20\x01(\tR\x02ID\x127\n\x06Params\x18\x02\x20\x03(\x0b2\x1f.feedapi.Co\
    ntractor.ParamsEntryR\x06Params\x1a9\n\x0bParamsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xa4\x04\n\x0fGetFeedResponse\x12$\n\x05Error\x18\x01\x20\
    \x01(\x0b2\x0e.feedapi.ErrorR\x05Error\x12\x14\n\x05Total\x18\x02\x20\
    \x01(\x03R\x05Total\x124\n\x04Feed\x18\x03\x20\x03(\x0b2\x20.feedapi.Get\
    FeedResponse.FeedRowR\x04Feed\x1a\x9e\x03\n\x07FeedRow\x12\x0e\n\x02ID\
    \x18\x01\x20\x01(\tR\x02ID\x12\x1c\n\tAccountID\x18\x02\x20\x01(\tR\tAcc\
    ountID\x12*\n\x10PartnerAccountID\x18\x03\x20\x01(\tR\x10PartnerAccountI\
    D\x128\n\tCreatedAt\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tCreatedAt\x123\n\nContractor\x18\x05\x20\x01(\x0b2\x13.feedapi.Contrac\
    torR\nContractor\x12$\n\rOperationType\x18\x06\x20\x01(\tR\rOperationTyp\
    e\x12D\n\x10OperationObjects\x18\x07\x20\x03(\x0b2\x18.feedapi.Operation\
    ObjectR\x10OperationObjects\x12*\n\x07Balance\x18\x08\x20\x01(\x0b2\x10.\
    feedapi.BalanceR\x07Balance\x122\n\x0cCurrentState\x18\t\x20\x01(\x0b2\
    \x0e.feedapi.StateR\x0cCurrentState\"g\n\x11GetFeedRowRequest\x12\x1e\n\
    \nFeedRowIDs\x18\x01\x20\x03(\tR\nFeedRowIDs\x12\x1c\n\tAccountID\x18\
    \x02\x20\x01(\tR\tAccountID\x12\x14\n\x05IsRaw\x18\x03\x20\x01(\x08R\x05\
    IsRaw\"\xec\x04\n\x12GetFeedRowResponse\x123\n\x04Rows\x18\x01\x20\x03(\
    \x0b2\x1f.feedapi.GetFeedRowResponse.RowR\x04Rows\x1a\xa0\x04\n\x03Row\
    \x12$\n\x05Error\x18\x01\x20\x01(\x0b2\x0e.feedapi.ErrorR\x05Error\x12\
    \x0e\n\x02ID\x18\x02\x20\x01(\tR\x02ID\x12\x1c\n\tAccountID\x18\x03\x20\
    \x01(\tR\tAccountID\x12*\n\x10PartnerAccountID\x18\x04\x20\x01(\tR\x10Pa\
    rtnerAccountID\x128\n\tCreatedAt\x18\x05\x20\x01(\x0b2\x1a.google.protob\
    uf.TimestampR\tCreatedAt\x123\n\nContractor\x18\x06\x20\x01(\x0b2\x13.fe\
    edapi.ContractorR\nContractor\x12$\n\rOperationType\x18\x07\x20\x01(\tR\
    \rOperationType\x12D\n\x10OperationObjects\x18\x08\x20\x03(\x0b2\x18.fee\
    dapi.OperationObjectR\x10OperationObjects\x12*\n\x07Balance\x18\t\x20\
    \x01(\x0b2\x10.feedapi.BalanceR\x07Balance\x12&\n\x06States\x18\n\x20\
    \x03(\x0b2\x0e.feedapi.StateR\x06States\x12\x1c\n\tStatesRaw\x18\x0b\x20\
    \x01(\x0cR\tStatesRaw\x122\n\x0cCurrentState\x18\x0c\x20\x01(\x0b2\x0e.f\
    eedapi.StateR\x0cCurrentState\x12\x18\n\x07Details\x18\r\x20\x01(\x0cR\
    \x07Details\"N\n\x17CreateContractorRequest\x123\n\nContractor\x18\x01\
    \x20\x01(\x0b2\x13.feedapi.ContractorR\nContractor\"@\n\x18CreateContrac\
    torResponse\x12$\n\x05Error\x18\x01\x20\x01(\x0b2\x0e.feedapi.ErrorR\x05\
    Error\"N\n\x17UpdateContractorRequest\x123\n\nContractor\x18\x01\x20\x01\
    (\x0b2\x13.feedapi.ContractorR\nContractor\"@\n\x18UpdateContractorRespo\
    nse\x12$\n\x05Error\x18\x01\x20\x01(\x0b2\x0e.feedapi.ErrorR\x05Error\"\
    \x17\n\x15GetContractorsRequest\"O\n\x16GetContractorsResponse\x125\n\
    \x0bContractors\x18\x01\x20\x03(\x0b2\x13.feedapi.ContractorR\x0bContrac\
    tors\"/\n\x0fHaveSeenRequest\x12\x1c\n\tAccountID\x18\x01\x20\x01(\tR\tA\
    ccountID\"\"\n\x10HaveSeenResponse\x12\x0e\n\x02Is\x18\x01\x20\x01(\x08R\
    \x02Is\"+\n\x0bSeenRequest\x12\x1c\n\tAccountID\x18\x01\x20\x01(\tR\tAcc\
    ountID\"\x0e\n\x0cSeenResponse\"I\n\x05Error\x12&\n\x04Code\x18\x01\x20\
    \x01(\x0e2\x12.feedapi.ErrorCodeR\x04Code\x12\x18\n\x07Message\x18\x02\
    \x20\x01(\tR\x07Message\"\xb6\x01\n\x18AsyncFeedRowCreatedEvent\x12\x1c\
    \n\tFeedRowID\x18\x01\x20\x01(\tR\tFeedRowID\x12\x1c\n\tAccountID\x18\
    \x02\x20\x01(\tR\tAccountID\x128\n\tCreatedAt\x18\x03\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\tCreatedAt\x12$\n\rOperationType\x18\x04\x20\
    \x01(\tR\rOperationType\"\xdc\x01\n\x18AsyncFeedRowUpdatedEvent\x12\x1c\
    \n\tFeedRowID\x18\x01\x20\x01(\tR\tFeedRowID\x12\x1c\n\tAccountID\x18\
    \x02\x20\x01(\tR\tAccountID\x12$\n\x05State\x18\x03\x20\x01(\x0b2\x0e.fe\
    edapi.StateR\x05State\x128\n\tUpdatedAt\x18\x04\x20\x01(\x0b2\x1a.google\
    .protobuf.TimestampR\tUpdatedAt\x12$\n\rOperationType\x18\x05\x20\x01(\t\
    R\rOperationType*\x87\x01\n\tErrorCode\x12\x12\n\x0eUndefinedError\x10\0\
    \x12\x13\n\x0fValidationError\x10\x01\x12\x11\n\rStateNotFound\x10\x02\
    \x12\x11\n\rFeedRowExists\x10\x03\x12\x16\n\x12ContractorNotFound\x10\
    \x04\x12\x13\n\x0fFeedRowNotFound\x10\x05*\x1d\n\x08OrderDir\x12\x07\n\
    \x03Asc\x10\0\x12\x08\n\x04Desc\x10\x012\xff\x05\n\x07FeedAPI\x12N\n\rCr\
    eateFeedRow\x12\x1d.feedapi.CreateFeedRowRequest\x1a\x1e.feedapi.CreateF\
    eedRowResponse\x12Z\n\x11AddStateToFeedRow\x12!.feedapi.AddStateToFeedRo\
    wRequest\x1a\".feedapi.AddStateToFeedRowResponse\x12H\n\x0bUpdateState\
    \x12\x1b.feedapi.UpdateStateRequest\x1a\x1c.feedapi.UpdateStateResponse\
    \x12<\n\x07GetFeed\x12\x17.feedapi.GetFeedRequest\x1a\x18.feedapi.GetFee\
    dResponse\x12E\n\nGetFeedRow\x12\x1a.feedapi.GetFeedRowRequest\x1a\x1b.f\
    eedapi.GetFeedRowResponse\x12W\n\x10CreateContractor\x12\x20.feedapi.Cre\
    ateContractorRequest\x1a!.feedapi.CreateContractorResponse\x12W\n\x10Upd\
    ateContractor\x12\x20.feedapi.UpdateContractorRequest\x1a!.feedapi.Updat\
    eContractorResponse\x12Q\n\x0eGetContractors\x12\x1e.feedapi.GetContract\
    orsRequest\x1a\x1f.feedapi.GetContractorsResponse\x12?\n\x08HaveSeen\x12\
    \x18.feedapi.HaveSeenRequest\x1a\x19.feedapi.HaveSeenResponse\x123\n\x04\
    Seen\x12\x14.feedapi.SeenRequest\x1a\x15.feedapi.SeenResponseB\x0bZ\t.;f\
    eedapiJ\xa2B\n\x07\x12\x05\0\0\xdd\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\0\x10\n\t\n\x02\x03\0\x12\x03\x04\0)\n\
    \x08\n\x01\x08\x12\x03\x06\0\x20\n\t\n\x02\x08\x0b\x12\x03\x06\0\x20\n\n\
    \n\x02\x06\0\x12\x04\x08\0\x18\x01\n\n\n\x03\x06\0\x01\x12\x03\x08\x08\
    \x0f\n\x0b\n\x04\x06\0\x02\0\x12\x03\t\x02J\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03\t\x06\x13\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\t\x14(\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03\t3H\n\x0c\n\x04\x06\0\x02\x01\x12\x04\n\x02\
    \x0b*\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\n\x06\x17\n\x0c\n\x05\x06\0\
    \x02\x01\x02\x12\x03\n\x180\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x0b\
    \x0f(\n\x0b\n\x04\x06\0\x02\x02\x12\x03\x0c\x02D\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03\x0c\x06\x11\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x0c\
    \x12$\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x0c/B\n\x0b\n\x04\x06\0\x02\
    \x03\x12\x03\r\x028\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\r\x06\r\n\x0c\
    \n\x05\x06\0\x02\x03\x02\x12\x03\r\x0e\x1c\n\x0c\n\x05\x06\0\x02\x03\x03\
    \x12\x03\r'6\n\x0b\n\x04\x06\0\x02\x04\x12\x03\x0e\x02A\n\x0c\n\x05\x06\
    \0\x02\x04\x01\x12\x03\x0e\x06\x10\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\
    \x0e\x11\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\x0e-?\n\x0c\n\x04\x06\0\
    \x02\x05\x12\x04\x10\x02\x11)\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x10\
    \x06\x16\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x10\x17.\n\x0c\n\x05\x06\
    \0\x02\x05\x03\x12\x03\x11\x0f'\n\x0c\n\x04\x06\0\x02\x06\x12\x04\x12\
    \x02\x13)\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03\x12\x06\x16\n\x0c\n\x05\
    \x06\0\x02\x06\x02\x12\x03\x12\x17.\n\x0c\n\x05\x06\0\x02\x06\x03\x12\
    \x03\x13\x0f'\n\x0b\n\x04\x06\0\x02\x07\x12\x03\x14\x02M\n\x0c\n\x05\x06\
    \0\x02\x07\x01\x12\x03\x14\x06\x14\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\
    \x14\x15*\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\x145K\n\x0b\n\x04\x06\0\
    \x02\x08\x12\x03\x16\x02;\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x16\x06\
    \x0e\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03\x16\x0f\x1e\n\x0c\n\x05\x06\0\
    \x02\x08\x03\x12\x03\x16)9\n\x0b\n\x04\x06\0\x02\t\x12\x03\x17\x02/\n\
    \x0c\n\x05\x06\0\x02\t\x01\x12\x03\x17\x06\n\n\x0c\n\x05\x06\0\x02\t\x02\
    \x12\x03\x17\x0b\x16\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03\x17!-\n\n\n\x02\
    \x04\0\x12\x04\x1a\0\x1f\x01\n\n\n\x03\x04\0\x01\x12\x03\x1a\x08\r\n\x0b\
    \n\x04\x04\0\x02\0\x12\x03\x1b\x02\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03\x1b\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1b\t\x0b\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x1b\x0e\x0f\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x1c\x02\x12\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1c\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03\x1c\t\r\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x1c\x10\x11\n$\n\x04\x04\0\x02\x02\x12\x03\x1d\x02\x13\"\x17\
    \x20map[sting]interface{}\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x1d\
    \x02\x07\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x1d\x08\x0e\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03\x1d\x11\x12\n\x0b\n\x04\x04\0\x02\x03\x12\x03\
    \x1e\x02*\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x1e\x02\x1b\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03\x1e\x1c%\n\x0c\n\x05\x04\0\x02\x03\x03\x12\
    \x03\x1e()\n\n\n\x02\x04\x01\x12\x04!\0%\x01\n\n\n\x03\x04\x01\x01\x12\
    \x03!\x08\x1a\n\x0b\n\x04\x04\x01\x02\0\x12\x03\"\x02\x17\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\"\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\"\t\x12\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\"\x15\x16\n\x0b\n\x04\
    \x04\x01\x02\x01\x12\x03#\x02\x17\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\
    \x03#\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03#\t\x12\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03#\x15\x16\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03$\x02\x12\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03$\x02\x07\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03$\x08\r\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03$\x10\x11\n\t\n\x02\x04\x02\x12\x03'\00\n\n\n\x03\x04\x02\x01\
    \x12\x03'\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\x12\x03'\x1e.\n\x0c\n\x05\
    \x04\x02\x02\0\x06\x12\x03'\x1e#\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03'$\
    )\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03',-\n\n\n\x02\x04\x03\x12\x04(\0-\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03(\x08\x0f\n\x1d\n\x04\x04\x03\x02\0\
    \x12\x03)\x02\x12\"\x10\x20Debit\x20|\x20Credit\n\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03)\t\r\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03)\x10\x11\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x03*\x02\x13\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03*\x02\x07\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03*\x08\x0e\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x03*\x11\x12\n\x0b\n\x04\x04\x03\x02\x02\x12\x03+\x02\x17\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03+\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03+\t\x12\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03+\x15\x16\
    \n\x0b\n\x04\x04\x03\x02\x03\x12\x03,\x02\x18\n\x0c\n\x05\x04\x03\x02\
    \x03\x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03,\t\x13\
    \n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03,\x16\x17\n\n\n\x02\x04\x04\x12\
    \x04/\04\x01\n\n\n\x03\x04\x04\x01\x12\x03/\x08\x17\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x030\x02\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x030\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\0\x01\x12\x030\t\x0b\n\x0c\n\x05\x04\x04\x02\0\
    \x03\x12\x030\x0e\x0f\n\x0b\n\x04\x04\x04\x02\x01\x12\x031\x02\x13\n\x0c\
    \n\x05\x04\x04\x02\x01\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x031\t\x0e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x031\x11\x12\n%\
    \n\x04\x04\x04\x02\x02\x12\x032\x02\x11\"\x18\x20optional\x20example\x20\
    image\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x032\t\x0c\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x032\
    \x0f\x10\n%\n\x04\x04\x04\x02\x03\x12\x033\x02\x11\"\x18\x20map[string]i\
    nterface{}\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x033\x02\x07\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x033\x08\x0c\n\x0c\n\x05\x04\x04\x02\x03\
    \x03\x12\x033\x0f\x10\n\n\n\x02\x04\x05\x12\x045\0E\x01\n\n\n\x03\x04\
    \x05\x01\x12\x035\x08\x1c\n\x0c\n\x04\x04\x05\x03\0\x12\x046\x02C\x03\n\
    \x0c\n\x05\x04\x05\x03\0\x01\x12\x036\n\r\n\r\n\x06\x04\x05\x03\0\x02\0\
    \x12\x037\x04\x15\n\x0e\n\x07\x04\x05\x03\0\x02\0\x05\x12\x037\x04\n\n\
    \x0e\n\x07\x04\x05\x03\0\x02\0\x01\x12\x037\x0b\x10\n\x0e\n\x07\x04\x05\
    \x03\0\x02\0\x03\x12\x037\x13\x14\n\r\n\x06\x04\x05\x03\0\x02\x01\x12\
    \x038\x04\x19\n\x0e\n\x07\x04\x05\x03\0\x02\x01\x05\x12\x038\x04\n\n\x0e\
    \n\x07\x04\x05\x03\0\x02\x01\x01\x12\x038\x0b\x14\n\x0e\n\x07\x04\x05\
    \x03\0\x02\x01\x03\x12\x038\x17\x18\n\r\n\x06\x04\x05\x03\0\x02\x02\x12\
    \x039\x04\x20\n\x0e\n\x07\x04\x05\x03\0\x02\x02\x05\x12\x039\x04\n\n\x0e\
    \n\x07\x04\x05\x03\0\x02\x02\x01\x12\x039\x0b\x1b\n\x0e\n\x07\x04\x05\
    \x03\0\x02\x02\x03\x12\x039\x1e\x1f\n\r\n\x06\x04\x05\x03\0\x02\x03\x12\
    \x03:\x04\x17\n\x0e\n\x07\x04\x05\x03\0\x02\x03\x05\x12\x03:\x04\n\n\x0e\
    \n\x07\x04\x05\x03\0\x02\x03\x01\x12\x03:\x0b\x12\n\x0e\n\x07\x04\x05\
    \x03\0\x02\x03\x03\x12\x03:\x15\x16\n\r\n\x06\x04\x05\x03\0\x02\x04\x12\
    \x03;\x04,\n\x0e\n\x07\x04\x05\x03\0\x02\x04\x06\x12\x03;\x04\x1d\n\x0e\
    \n\x07\x04\x05\x03\0\x02\x04\x01\x12\x03;\x1e'\n\x0e\n\x07\x04\x05\x03\0\
    \x02\x04\x03\x12\x03;*+\n@\n\x06\x04\x05\x03\0\x02\x05\x12\x03<\x04\x1d\
    \"1\x20\"p2p\x20Sell\x20|\x20p2p\x20Buy\x20|\x20Deposit(currency|asset)\
    \x20|\n\n\x0e\n\x07\x04\x05\x03\0\x02\x05\x05\x12\x03<\x04\n\n\x0e\n\x07\
    \x04\x05\x03\0\x02\x05\x01\x12\x03<\x0b\x18\n\x0e\n\x07\x04\x05\x03\0\
    \x02\x05\x03\x12\x03<\x1b\x1c\n*\n\x06\x04\x05\x03\0\x02\x06\x12\x03>\
    \x042\x1a\x1b\x20Withdraw(currency|asset)\"\n\n\x0e\n\x07\x04\x05\x03\0\
    \x02\x06\x04\x12\x03>\x04\x0c\n\x0e\n\x07\x04\x05\x03\0\x02\x06\x06\x12\
    \x03>\r\x1c\n\x0e\n\x07\x04\x05\x03\0\x02\x06\x01\x12\x03>\x1d-\n\x0e\n\
    \x07\x04\x05\x03\0\x02\x06\x03\x12\x03>01\n\r\n\x06\x04\x05\x03\0\x02\
    \x07\x12\x03?\x04\x18\n\x0e\n\x07\x04\x05\x03\0\x02\x07\x06\x12\x03?\x04\
    \x0b\n\x0e\n\x07\x04\x05\x03\0\x02\x07\x01\x12\x03?\x0c\x13\n\x0e\n\x07\
    \x04\x05\x03\0\x02\x07\x03\x12\x03?\x16\x17\n\r\n\x06\x04\x05\x03\0\x02\
    \x08\x12\x03@\x04\x1c\n\x0e\n\x07\x04\x05\x03\0\x02\x08\x05\x12\x03@\x04\
    \n\n\x0e\n\x07\x04\x05\x03\0\x02\x08\x01\x12\x03@\x0b\x17\n\x0e\n\x07\
    \x04\x05\x03\0\x02\x08\x03\x12\x03@\x1a\x1b\n\r\n\x06\x04\x05\x03\0\x02\
    \t\x12\x03A\x04\x15\n\x0e\n\x07\x04\x05\x03\0\x02\t\x06\x12\x03A\x04\t\n\
    \x0e\n\x07\x04\x05\x03\0\x02\t\x01\x12\x03A\n\x0f\n\x0e\n\x07\x04\x05\
    \x03\0\x02\t\x03\x12\x03A\x12\x14\n'\n\x06\x04\x05\x03\0\x02\n\x12\x03B\
    \x04\x17\"\x18\x20map[string]interface{}\n\n\x0e\n\x07\x04\x05\x03\0\x02\
    \n\x05\x12\x03B\x04\t\n\x0e\n\x07\x04\x05\x03\0\x02\n\x01\x12\x03B\n\x11\
    \n\x0e\n\x07\x04\x05\x03\0\x02\n\x03\x12\x03B\x14\x16\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03D\x02\x18\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03D\x02\n\
    \n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03D\x0b\x0e\n\x0c\n\x05\x04\x05\x02\
    \0\x01\x12\x03D\x0f\x13\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03D\x16\x17\n\
    \n\n\x02\x04\x06\x12\x04G\0M\x01\n\n\n\x03\x04\x06\x01\x12\x03G\x08\x1d\
    \n\x0c\n\x04\x04\x06\x03\0\x12\x04H\x02K\x03\n\x0c\n\x05\x04\x06\x03\0\
    \x01\x12\x03H\n\r\n\r\n\x06\x04\x06\x03\0\x02\0\x12\x03I\x04\x10\n\x0e\n\
    \x07\x04\x06\x03\0\x02\0\x05\x12\x03I\x04\x08\n\x0e\n\x07\x04\x06\x03\0\
    \x02\0\x01\x12\x03I\t\x0b\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03I\
    \x0e\x0f\n\r\n\x06\x04\x06\x03\0\x02\x01\x12\x03J\x04\x14\n\x0e\n\x07\
    \x04\x06\x03\0\x02\x01\x06\x12\x03J\x04\t\n\x0e\n\x07\x04\x06\x03\0\x02\
    \x01\x01\x12\x03J\n\x0f\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x03J\
    \x12\x13\n\x0b\n\x04\x04\x06\x02\0\x12\x03L\x02\x18\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03L\x02\n\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03L\x0b\x0e\
    \n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03L\x0f\x13\n\x0c\n\x05\x04\x06\x02\
    \0\x03\x12\x03L\x16\x17\n\n\n\x02\x04\x07\x12\x04O\0V\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03O\x08\x20\n\x0c\n\x04\x04\x07\x03\0\x12\x04P\x02T\x03\n\
    \x0c\n\x05\x04\x07\x03\0\x01\x12\x03P\n\x12\n\r\n\x06\x04\x07\x03\0\x02\
    \0\x12\x03Q\x04\x19\n\x0e\n\x07\x04\x07\x03\0\x02\0\x05\x12\x03Q\x04\n\n\
    \x0e\n\x07\x04\x07\x03\0\x02\0\x01\x12\x03Q\x0b\x14\n\x0e\n\x07\x04\x07\
    \x03\0\x02\0\x03\x12\x03Q\x17\x18\n\r\n\x06\x04\x07\x03\0\x02\x01\x12\
    \x03R\x04\x19\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x03R\x04\n\n\x0e\
    \n\x07\x04\x07\x03\0\x02\x01\x01\x12\x03R\x0b\x14\n\x0e\n\x07\x04\x07\
    \x03\0\x02\x01\x03\x12\x03R\x17\x18\n\r\n\x06\x04\x07\x03\0\x02\x02\x12\
    \x03S\x04\x14\n\x0e\n\x07\x04\x07\x03\0\x02\x02\x06\x12\x03S\x04\t\n\x0e\
    \n\x07\x04\x07\x03\0\x02\x02\x01\x12\x03S\n\x0f\n\x0e\n\x07\x04\x07\x03\
    \0\x02\x02\x03\x12\x03S\x12\x13\n\x0b\n\x04\x04\x07\x02\0\x12\x03U\x02\"\
    \n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x07\x02\0\
    \x06\x12\x03U\x0b\x13\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03U\x14\x1d\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03U\x20!\n\n\n\x02\x04\x08\x12\x04X\0^\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03X\x08!\n\x0c\n\x04\x04\x08\x03\0\x12\
    \x04Y\x02\\\x03\n\x0c\n\x05\x04\x08\x03\0\x01\x12\x03Y\n\x12\n\r\n\x06\
    \x04\x08\x03\0\x02\0\x12\x03Z\x04\x10\n\x0e\n\x07\x04\x08\x03\0\x02\0\
    \x05\x12\x03Z\x04\x08\n\x0e\n\x07\x04\x08\x03\0\x02\0\x01\x12\x03Z\t\x0b\
    \n\x0e\n\x07\x04\x08\x03\0\x02\0\x03\x12\x03Z\x0e\x0f\n\r\n\x06\x04\x08\
    \x03\0\x02\x01\x12\x03[\x04\x14\n\x0e\n\x07\x04\x08\x03\0\x02\x01\x06\
    \x12\x03[\x04\t\n\x0e\n\x07\x04\x08\x03\0\x02\x01\x01\x12\x03[\n\x0f\n\
    \x0e\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x03[\x12\x13\n\x0b\n\x04\x04\
    \x08\x02\0\x12\x03]\x02\"\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03]\x02\n\n\
    \x0c\n\x05\x04\x08\x02\0\x06\x12\x03]\x0b\x13\n\x0c\n\x05\x04\x08\x02\0\
    \x01\x12\x03]\x14\x1d\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03]\x20!\n\n\n\
    \x02\x04\t\x12\x04`\0v\x01\n\n\n\x03\x04\t\x01\x12\x03`\x08\x16\n\x0b\n\
    \x04\x04\t\x02\0\x12\x03a\x02\x12\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03a\
    \x02\x07\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03a\x08\r\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03a\x10\x11\n\x0b\n\x04\x04\t\x02\x01\x12\x03b\x02\x13\n\
    \x0c\n\x05\x04\t\x02\x01\x05\x12\x03b\x02\x07\n\x0c\n\x05\x04\t\x02\x01\
    \x01\x12\x03b\x08\x0e\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03b\x11\x12\n\
    \x0b\n\x04\x04\t\x02\x02\x12\x03d\x02\x17\n\x0c\n\x05\x04\t\x02\x02\x05\
    \x12\x03d\x02\x08\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03d\t\x12\n\x0c\n\
    \x05\x04\t\x02\x02\x03\x12\x03d\x15\x16\n\x0b\n\x04\x04\t\x02\x03\x12\
    \x03e\x02\x15\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03e\x02\x08\n\x0c\n\x05\
    \x04\t\x02\x03\x01\x12\x03e\t\x10\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03e\
    \x13\x14\n\x0c\n\x04\x04\t\x03\0\x12\x04g\x02k\x03\n\x0c\n\x05\x04\t\x03\
    \0\x01\x12\x03g\n\x10\nB\n\x06\x04\t\x03\0\x02\0\x12\x03i\x04\x19\x1a3\
    \x20Example:\x20{\x20fieldName:\x20Params.active,\x20value:\x20true}\n\n\
    \x0e\n\x07\x04\t\x03\0\x02\0\x05\x12\x03i\x04\n\n\x0e\n\x07\x04\t\x03\0\
    \x02\0\x01\x12\x03i\x0b\x14\n\x0e\n\x07\x04\t\x03\0\x02\0\x03\x12\x03i\
    \x17\x18\n\r\n\x06\x04\t\x03\0\x02\x01\x12\x03j\x04\x1a\n\x0e\n\x07\x04\
    \t\x03\0\x02\x01\x05\x12\x03j\x04\n\n\x0e\n\x07\x04\t\x03\0\x02\x01\x01\
    \x12\x03j\x0b\x15\n\x0e\n\x07\x04\t\x03\0\x02\x01\x03\x12\x03j\x18\x19\n\
    \x0b\n\x04\x04\t\x02\x04\x12\x03l\x02'\n\x0c\n\x05\x04\t\x02\x04\x04\x12\
    \x03l\x02\n\n\x0c\n\x05\x04\t\x02\x04\x06\x12\x03l\x0b\x11\n\x0c\n\x05\
    \x04\t\x02\x04\x01\x12\x03l\x12\"\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03l\
    %&\n\x0c\n\x04\x04\t\x03\x01\x12\x04n\x02r\x03\n\x0c\n\x05\x04\t\x03\x01\
    \x01\x12\x03n\n\x0f\n#\n\x06\x04\t\x03\x01\x02\0\x12\x03p\x04\x19\x1a\
    \x14\x20Params.active\x20desc\n\n\x0e\n\x07\x04\t\x03\x01\x02\0\x05\x12\
    \x03p\x04\n\n\x0e\n\x07\x04\t\x03\x01\x02\0\x01\x12\x03p\x0b\x14\n\x0e\n\
    \x07\x04\t\x03\x01\x02\0\x03\x12\x03p\x17\x18\n\r\n\x06\x04\t\x03\x01\
    \x02\x01\x12\x03q\x04\x15\n\x0e\n\x07\x04\t\x03\x01\x02\x01\x06\x12\x03q\
    \x04\x0c\n\x0e\n\x07\x04\t\x03\x01\x02\x01\x01\x12\x03q\r\x10\n\x0e\n\
    \x07\x04\t\x03\x01\x02\x01\x03\x12\x03q\x13\x14\n\x0b\n\x04\x04\t\x02\
    \x05\x12\x03s\x02\x1c\n\x0c\n\x05\x04\t\x02\x05\x04\x12\x03s\x02\n\n\x0c\
    \n\x05\x04\t\x02\x05\x06\x12\x03s\x0b\x10\n\x0c\n\x05\x04\t\x02\x05\x01\
    \x12\x03s\x11\x17\n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03s\x1a\x1b\n\x0b\n\
    \x04\x04\t\x02\x06\x12\x03u\x02\x1e\n\x0c\n\x05\x04\t\x02\x06\x05\x12\
    \x03u\x02\x08\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03u\t\x19\n\x0c\n\x05\
    \x04\t\x02\x06\x03\x12\x03u\x1c\x1d\n\n\n\x02\x04\n\x12\x04x\0{\x01\n\n\
    \n\x03\x04\n\x01\x12\x03x\x08\x12\n\x0b\n\x04\x04\n\x02\0\x12\x03y\x02\
    \x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03y\x02\x08\n\x0c\n\x05\x04\n\x02\
    \0\x01\x12\x03y\t\x0b\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03y\x0e\x0f\n\x0b\
    \n\x04\x04\n\x02\x01\x12\x03z\x02!\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03\
    z\x02\x15\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03z\x16\x1c\n\x0c\n\x05\x04\
    \n\x02\x01\x03\x12\x03z\x1f\x20\n\x0b\n\x02\x04\x0b\x12\x05}\0\x8c\x01\
    \x01\n\n\n\x03\x04\x0b\x01\x12\x03}\x08\x17\n\x0b\n\x04\x04\x0b\x02\0\
    \x12\x03~\x02\x12\n\x0c\n\x05\x04\x0b\x02\0\x06\x12\x03~\x02\x07\n\x0c\n\
    \x05\x04\x0b\x02\0\x01\x12\x03~\x08\r\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\
    \x03~\x10\x11\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03\x7f\x02\x12\n\x0c\n\
    \x05\x04\x0b\x02\x01\x05\x12\x03\x7f\x02\x07\n\x0c\n\x05\x04\x0b\x02\x01\
    \x01\x12\x03\x7f\x08\r\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03\x7f\x10\
    \x11\n\x0e\n\x04\x04\x0b\x03\0\x12\x06\x80\x01\x02\x8a\x01\x03\n\r\n\x05\
    \x04\x0b\x03\0\x01\x12\x04\x80\x01\n\x11\n\x0e\n\x06\x04\x0b\x03\0\x02\0\
    \x12\x04\x81\x01\x04\x12\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x05\x12\x04\x81\
    \x01\x04\n\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x01\x12\x04\x81\x01\x0b\r\n\
    \x0f\n\x07\x04\x0b\x03\0\x02\0\x03\x12\x04\x81\x01\x10\x11\n\x0e\n\x06\
    \x04\x0b\x03\0\x02\x01\x12\x04\x82\x01\x04\x19\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\x01\x05\x12\x04\x82\x01\x04\n\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x01\
    \x12\x04\x82\x01\x0b\x14\n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x03\x12\x04\
    \x82\x01\x17\x18\n\x0e\n\x06\x04\x0b\x03\0\x02\x02\x12\x04\x83\x01\x04\
    \x20\n\x0f\n\x07\x04\x0b\x03\0\x02\x02\x05\x12\x04\x83\x01\x04\n\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x02\x01\x12\x04\x83\x01\x0b\x1b\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\x02\x03\x12\x04\x83\x01\x1e\x1f\n\x0e\n\x06\x04\x0b\x03\0\
    \x02\x03\x12\x04\x84\x01\x04,\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x06\x12\
    \x04\x84\x01\x04\x1d\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x01\x12\x04\x84\
    \x01\x1e'\n\x0f\n\x07\x04\x0b\x03\0\x02\x03\x03\x12\x04\x84\x01*+\n\x0e\
    \n\x06\x04\x0b\x03\0\x02\x04\x12\x04\x85\x01\x04\x1e\n\x0f\n\x07\x04\x0b\
    \x03\0\x02\x04\x06\x12\x04\x85\x01\x04\x0e\n\x0f\n\x07\x04\x0b\x03\0\x02\
    \x04\x01\x12\x04\x85\x01\x0f\x19\n\x0f\n\x07\x04\x0b\x03\0\x02\x04\x03\
    \x12\x04\x85\x01\x1c\x1d\n\x0e\n\x06\x04\x0b\x03\0\x02\x05\x12\x04\x86\
    \x01\x04\x1d\n\x0f\n\x07\x04\x0b\x03\0\x02\x05\x05\x12\x04\x86\x01\x04\n\
    \n\x0f\n\x07\x04\x0b\x03\0\x02\x05\x01\x12\x04\x86\x01\x0b\x18\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x05\x03\x12\x04\x86\x01\x1b\x1c\n\x0e\n\x06\x04\
    \x0b\x03\0\x02\x06\x12\x04\x87\x01\x042\n\x0f\n\x07\x04\x0b\x03\0\x02\
    \x06\x04\x12\x04\x87\x01\x04\x0c\n\x0f\n\x07\x04\x0b\x03\0\x02\x06\x06\
    \x12\x04\x87\x01\r\x1c\n\x0f\n\x07\x04\x0b\x03\0\x02\x06\x01\x12\x04\x87\
    \x01\x1d-\n\x0f\n\x07\x04\x0b\x03\0\x02\x06\x03\x12\x04\x87\x0101\n\x0e\
    \n\x06\x04\x0b\x03\0\x02\x07\x12\x04\x88\x01\x04\x18\n\x0f\n\x07\x04\x0b\
    \x03\0\x02\x07\x06\x12\x04\x88\x01\x04\x0b\n\x0f\n\x07\x04\x0b\x03\0\x02\
    \x07\x01\x12\x04\x88\x01\x0c\x13\n\x0f\n\x07\x04\x0b\x03\0\x02\x07\x03\
    \x12\x04\x88\x01\x16\x17\n\x0e\n\x06\x04\x0b\x03\0\x02\x08\x12\x04\x89\
    \x01\x04\x1b\n\x0f\n\x07\x04\x0b\x03\0\x02\x08\x06\x12\x04\x89\x01\x04\t\
    \n\x0f\n\x07\x04\x0b\x03\0\x02\x08\x01\x12\x04\x89\x01\n\x16\n\x0f\n\x07\
    \x04\x0b\x03\0\x02\x08\x03\x12\x04\x89\x01\x19\x1a\n\x0c\n\x04\x04\x0b\
    \x02\x02\x12\x04\x8b\x01\x02\x1c\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\
    \x8b\x01\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\x8b\x01\x0b\x12\n\r\
    \n\x05\x04\x0b\x02\x02\x01\x12\x04\x8b\x01\x13\x17\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\x8b\x01\x1a\x1b\n\x0c\n\x02\x04\x0c\x12\x06\x8e\x01\0\
    \x92\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8e\x01\x08\x19\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\x8f\x01\x02!\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\
    \x8f\x01\x02\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x8f\x01\x0b\x11\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\x8f\x01\x12\x1c\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\x8f\x01\x1f\x20\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x90\x01\
    \x02\x17\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\
    \x04\x0c\x02\x01\x01\x12\x04\x90\x01\t\x12\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\x90\x01\x15\x16\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x91\x01\x02\
    \x11\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x91\x01\x02\x06\n\r\n\x05\x04\
    \x0c\x02\x02\x01\x12\x04\x91\x01\x07\x0c\n\r\n\x05\x04\x0c\x02\x02\x03\
    \x12\x04\x91\x01\x0f\x10\n\x0c\n\x02\x04\r\x12\x06\x94\x01\0\xa5\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\x94\x01\x08\x1a\n\x0e\n\x04\x04\r\x03\0\
    \x12\x06\x95\x01\x02\xa3\x01\x03\n\r\n\x05\x04\r\x03\0\x01\x12\x04\x95\
    \x01\n\r\n\x0e\n\x06\x04\r\x03\0\x02\0\x12\x04\x96\x01\x04\x14\n\x0f\n\
    \x07\x04\r\x03\0\x02\0\x06\x12\x04\x96\x01\x04\t\n\x0f\n\x07\x04\r\x03\0\
    \x02\0\x01\x12\x04\x96\x01\n\x0f\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\
    \x04\x96\x01\x12\x13\n\x0e\n\x06\x04\r\x03\0\x02\x01\x12\x04\x97\x01\x04\
    \x12\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\x04\x97\x01\x04\n\n\x0f\n\
    \x07\x04\r\x03\0\x02\x01\x01\x12\x04\x97\x01\x0b\r\n\x0f\n\x07\x04\r\x03\
    \0\x02\x01\x03\x12\x04\x97\x01\x10\x11\n\x0e\n\x06\x04\r\x03\0\x02\x02\
    \x12\x04\x98\x01\x04\x19\n\x0f\n\x07\x04\r\x03\0\x02\x02\x05\x12\x04\x98\
    \x01\x04\n\n\x0f\n\x07\x04\r\x03\0\x02\x02\x01\x12\x04\x98\x01\x0b\x14\n\
    \x0f\n\x07\x04\r\x03\0\x02\x02\x03\x12\x04\x98\x01\x17\x18\n\x0e\n\x06\
    \x04\r\x03\0\x02\x03\x12\x04\x99\x01\x04\x20\n\x0f\n\x07\x04\r\x03\0\x02\
    \x03\x05\x12\x04\x99\x01\x04\n\n\x0f\n\x07\x04\r\x03\0\x02\x03\x01\x12\
    \x04\x99\x01\x0b\x1b\n\x0f\n\x07\x04\r\x03\0\x02\x03\x03\x12\x04\x99\x01\
    \x1e\x1f\n\x0e\n\x06\x04\r\x03\0\x02\x04\x12\x04\x9a\x01\x04,\n\x0f\n\
    \x07\x04\r\x03\0\x02\x04\x06\x12\x04\x9a\x01\x04\x1d\n\x0f\n\x07\x04\r\
    \x03\0\x02\x04\x01\x12\x04\x9a\x01\x1e'\n\x0f\n\x07\x04\r\x03\0\x02\x04\
    \x03\x12\x04\x9a\x01*+\n\x0e\n\x06\x04\r\x03\0\x02\x05\x12\x04\x9b\x01\
    \x04\x1e\n\x0f\n\x07\x04\r\x03\0\x02\x05\x06\x12\x04\x9b\x01\x04\x0e\n\
    \x0f\n\x07\x04\r\x03\0\x02\x05\x01\x12\x04\x9b\x01\x0f\x19\n\x0f\n\x07\
    \x04\r\x03\0\x02\x05\x03\x12\x04\x9b\x01\x1c\x1d\n\x0e\n\x06\x04\r\x03\0\
    \x02\x06\x12\x04\x9c\x01\x04\x1d\n\x0f\n\x07\x04\r\x03\0\x02\x06\x05\x12\
    \x04\x9c\x01\x04\n\n\x0f\n\x07\x04\r\x03\0\x02\x06\x01\x12\x04\x9c\x01\
    \x0b\x18\n\x0f\n\x07\x04\r\x03\0\x02\x06\x03\x12\x04\x9c\x01\x1b\x1c\n\
    \x0e\n\x06\x04\r\x03\0\x02\x07\x12\x04\x9d\x01\x042\n\x0f\n\x07\x04\r\
    \x03\0\x02\x07\x04\x12\x04\x9d\x01\x04\x0c\n\x0f\n\x07\x04\r\x03\0\x02\
    \x07\x06\x12\x04\x9d\x01\r\x1c\n\x0f\n\x07\x04\r\x03\0\x02\x07\x01\x12\
    \x04\x9d\x01\x1d-\n\x0f\n\x07\x04\r\x03\0\x02\x07\x03\x12\x04\x9d\x0101\
    \n\x0e\n\x06\x04\r\x03\0\x02\x08\x12\x04\x9e\x01\x04\x18\n\x0f\n\x07\x04\
    \r\x03\0\x02\x08\x06\x12\x04\x9e\x01\x04\x0b\n\x0f\n\x07\x04\r\x03\0\x02\
    \x08\x01\x12\x04\x9e\x01\x0c\x13\n\x0f\n\x07\x04\r\x03\0\x02\x08\x03\x12\
    \x04\x9e\x01\x16\x17\n\x1f\n\x06\x04\r\x03\0\x02\t\x12\x04\x9f\x01\x04\
    \x1f\"\x0f\x20IsRaw\x20=\x20false\n\n\x0f\n\x07\x04\r\x03\0\x02\t\x04\
    \x12\x04\x9f\x01\x04\x0c\n\x0f\n\x07\x04\r\x03\0\x02\t\x06\x12\x04\x9f\
    \x01\r\x12\n\x0f\n\x07\x04\r\x03\0\x02\t\x01\x12\x04\x9f\x01\x13\x19\n\
    \x0f\n\x07\x04\r\x03\0\x02\t\x03\x12\x04\x9f\x01\x1c\x1e\n\x1e\n\x06\x04\
    \r\x03\0\x02\n\x12\x04\xa0\x01\x04\x19\"\x0e\x20IsRaw\x20=\x20true\n\n\
    \x0f\n\x07\x04\r\x03\0\x02\n\x05\x12\x04\xa0\x01\x04\t\n\x0f\n\x07\x04\r\
    \x03\0\x02\n\x01\x12\x04\xa0\x01\n\x13\n\x0f\n\x07\x04\r\x03\0\x02\n\x03\
    \x12\x04\xa0\x01\x16\x18\n\x0e\n\x06\x04\r\x03\0\x02\x0b\x12\x04\xa1\x01\
    \x04\x1c\n\x0f\n\x07\x04\r\x03\0\x02\x0b\x06\x12\x04\xa1\x01\x04\t\n\x0f\
    \n\x07\x04\r\x03\0\x02\x0b\x01\x12\x04\xa1\x01\n\x16\n\x0f\n\x07\x04\r\
    \x03\0\x02\x0b\x03\x12\x04\xa1\x01\x19\x1b\n\x0e\n\x06\x04\r\x03\0\x02\
    \x0c\x12\x04\xa2\x01\x04\x17\n\x0f\n\x07\x04\r\x03\0\x02\x0c\x05\x12\x04\
    \xa2\x01\x04\t\n\x0f\n\x07\x04\r\x03\0\x02\x0c\x01\x12\x04\xa2\x01\n\x11\
    \n\x0f\n\x07\x04\r\x03\0\x02\x0c\x03\x12\x04\xa2\x01\x14\x16\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\xa4\x01\x02\x18\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xa4\x01\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xa4\x01\x0b\x0e\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xa4\x01\x0f\x13\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xa4\x01\x16\x17\n\n\n\x02\x04\x0e\x12\x04\xa7\x01\0>\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\xa7\x01\x08\x1f\n\x0c\n\x04\x04\x0e\x02\0\x12\
    \x04\xa7\x01\"<\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xa7\x01\",\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xa7\x01-7\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xa7\x01:;\n\n\n\x02\x04\x0f\x12\x04\xa9\x01\05\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xa9\x01\x08\x20\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xa9\x01#3\n\r\
    \n\x05\x04\x0f\x02\0\x06\x12\x04\xa9\x01#(\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xa9\x01).\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa9\x0112\n\n\n\
    \x02\x04\x10\x12\x04\xab\x01\0>\n\x0b\n\x03\x04\x10\x01\x12\x04\xab\x01\
    \x08\x1f\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xab\x01\"<\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xab\x01\",\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xab\
    \x01-7\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xab\x01:;\n\n\n\x02\x04\x11\
    \x12\x04\xad\x01\05\n\x0b\n\x03\x04\x11\x01\x12\x04\xad\x01\x08\x20\n\
    \x0c\n\x04\x04\x11\x02\0\x12\x04\xad\x01#3\n\r\n\x05\x04\x11\x02\0\x06\
    \x12\x04\xad\x01#(\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xad\x01).\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xad\x0112\n\n\n\x02\x04\x12\x12\x04\xaf\
    \x01\0\x20\n\x0b\n\x03\x04\x12\x01\x12\x04\xaf\x01\x08\x1d\n\n\n\x02\x04\
    \x13\x12\x04\xb1\x01\0G\n\x0b\n\x03\x04\x13\x01\x12\x04\xb1\x01\x08\x1e\
    \n\x0c\n\x04\x04\x13\x02\0\x12\x04\xb1\x01!E\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\xb1\x01!)\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xb1\x01*4\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xb1\x015@\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\xb1\x01CD\n\n\n\x02\x04\x14\x12\x04\xb3\x01\01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xb3\x01\x08\x17\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xb3\x01\
    \x1a/\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xb3\x01\x1a\x20\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xb3\x01!*\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xb3\
    \x01-.\n\n\n\x02\x04\x15\x12\x04\xb5\x01\0)\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xb5\x01\x08\x18\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb5\x01\x1b'\n\r\
    \n\x05\x04\x15\x02\0\x05\x12\x04\xb5\x01\x1b\x1f\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xb5\x01\x20\"\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb5\x01%&\
    \n\n\n\x02\x04\x16\x12\x04\xb7\x01\0-\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \xb7\x01\x08\x13\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xb7\x01\x16+\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xb7\x01\x16\x1c\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xb7\x01\x1d&\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xb7\x01)*\
    \n\n\n\x02\x04\x17\x12\x04\xb9\x01\0\x17\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xb9\x01\x08\x14\n\x0c\n\x02\x04\x18\x12\x06\xbb\x01\0\xbe\x01\x01\n\x0b\
    \n\x03\x04\x18\x01\x12\x04\xbb\x01\x08\r\n\x0c\n\x04\x04\x18\x02\0\x12\
    \x04\xbc\x01\x02\x15\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xbc\x01\x02\x0b\
    \n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xbc\x01\x0c\x10\n\r\n\x05\x04\x18\
    \x02\0\x03\x12\x04\xbc\x01\x13\x14\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\
    \xbd\x01\x02\x15\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xbd\x01\x02\x08\n\
    \r\n\x05\x04\x18\x02\x01\x01\x12\x04\xbd\x01\t\x10\n\r\n\x05\x04\x18\x02\
    \x01\x03\x12\x04\xbd\x01\x13\x14\n\x0c\n\x02\x05\0\x12\x06\xc0\x01\0\xc7\
    \x01\x01\n\x0b\n\x03\x05\0\x01\x12\x04\xc0\x01\x05\x0e\n\x0c\n\x04\x05\0\
    \x02\0\x12\x04\xc1\x01\x02\x15\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xc1\x01\
    \x02\x10\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xc1\x01\x13\x14\n\x0c\n\x04\
    \x05\0\x02\x01\x12\x04\xc2\x01\x02\x16\n\r\n\x05\x05\0\x02\x01\x01\x12\
    \x04\xc2\x01\x02\x11\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xc2\x01\x14\x15\
    \n\x0c\n\x04\x05\0\x02\x02\x12\x04\xc3\x01\x02\x14\n\r\n\x05\x05\0\x02\
    \x02\x01\x12\x04\xc3\x01\x02\x0f\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xc3\
    \x01\x12\x13\n\x0c\n\x04\x05\0\x02\x03\x12\x04\xc4\x01\x02\x14\n\r\n\x05\
    \x05\0\x02\x03\x01\x12\x04\xc4\x01\x02\x0f\n\r\n\x05\x05\0\x02\x03\x02\
    \x12\x04\xc4\x01\x12\x13\n\x0c\n\x04\x05\0\x02\x04\x12\x04\xc5\x01\x02\
    \x19\n\r\n\x05\x05\0\x02\x04\x01\x12\x04\xc5\x01\x02\x14\n\r\n\x05\x05\0\
    \x02\x04\x02\x12\x04\xc5\x01\x17\x18\n\x0c\n\x04\x05\0\x02\x05\x12\x04\
    \xc6\x01\x02\x16\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\xc6\x01\x02\x11\n\r\
    \n\x05\x05\0\x02\x05\x02\x12\x04\xc6\x01\x14\x15\n\x0c\n\x02\x05\x01\x12\
    \x06\xc9\x01\0\xcc\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xc9\x01\x05\r\
    \n\x0c\n\x04\x05\x01\x02\0\x12\x04\xca\x01\x02\n\n\r\n\x05\x05\x01\x02\0\
    \x01\x12\x04\xca\x01\x02\x05\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xca\x01\
    \x08\t\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xcb\x01\x02\x0b\n\r\n\x05\x05\
    \x01\x02\x01\x01\x12\x04\xcb\x01\x02\x06\n\r\n\x05\x05\x01\x02\x01\x02\
    \x12\x04\xcb\x01\t\n\n\x1d\n\x02\x04\x19\x12\x06\xcf\x01\0\xd4\x01\x01\
    \x1a\x0f\x20asyncly:fires\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xcf\x01\x08\
    \x20\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xd0\x01\x02\x17\n\r\n\x05\x04\x19\
    \x02\0\x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \xd0\x01\t\x12\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd0\x01\x15\x16\n\x0c\
    \n\x04\x04\x19\x02\x01\x12\x04\xd1\x01\x02\x17\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xd1\x01\x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd1\
    \x01\t\x12\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd1\x01\x15\x16\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xd2\x01\x02*\n\r\n\x05\x04\x19\x02\x02\x06\
    \x12\x04\xd2\x01\x02\x1b\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd2\x01\
    \x1c%\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xd2\x01()\n\x0c\n\x04\x04\
    \x19\x02\x03\x12\x04\xd3\x01\x02\x1b\n\r\n\x05\x04\x19\x02\x03\x05\x12\
    \x04\xd3\x01\x02\x08\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xd3\x01\t\x16\
    \n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xd3\x01\x19\x1a\n\x1d\n\x02\x04\
    \x1a\x12\x06\xd7\x01\0\xdd\x01\x01\x1a\x0f\x20asyncly:fires\n\n\x0b\n\
    \x03\x04\x1a\x01\x12\x04\xd7\x01\x08\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\
    \x04\xd8\x01\x02\x17\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd8\x01\x02\x08\
    \n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd8\x01\t\x12\n\r\n\x05\x04\x1a\x02\
    \0\x03\x12\x04\xd8\x01\x15\x16\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd9\
    \x01\x02\x17\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xd9\x01\x02\x08\n\r\n\
    \x05\x04\x1a\x02\x01\x01\x12\x04\xd9\x01\t\x12\n\r\n\x05\x04\x1a\x02\x01\
    \x03\x12\x04\xd9\x01\x15\x16\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xda\x01\
    \x02\x12\n\r\n\x05\x04\x1a\x02\x02\x06\x12\x04\xda\x01\x02\x07\n\r\n\x05\
    \x04\x1a\x02\x02\x01\x12\x04\xda\x01\x08\r\n\r\n\x05\x04\x1a\x02\x02\x03\
    \x12\x04\xda\x01\x10\x11\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xdb\x01\x02\
    *\n\r\n\x05\x04\x1a\x02\x03\x06\x12\x04\xdb\x01\x02\x1b\n\r\n\x05\x04\
    \x1a\x02\x03\x01\x12\x04\xdb\x01\x1c%\n\r\n\x05\x04\x1a\x02\x03\x03\x12\
    \x04\xdb\x01()\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\xdc\x01\x02\x1b\n\r\n\
    \x05\x04\x1a\x02\x04\x05\x12\x04\xdc\x01\x02\x08\n\r\n\x05\x04\x1a\x02\
    \x04\x01\x12\x04\xdc\x01\t\x16\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xdc\
    \x01\x19\x1ab\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
